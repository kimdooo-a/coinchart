폴리 에이전트 오케스트레이션(Poly-Agentic Orchestration): 자율형 AI 개발 환경 구축을 위한 인프라 프로비저닝 및 노코드 부트스트래핑 전략 심층 연구 보고서
1. 서론: 에이전트 중심 소프트웨어 엔지니어링의 도래
소프트웨어 엔지니어링의 패러다임이 근본적인 위상 전이(Phase Shift)를 겪고 있다. 인간 개발자가 도구를 직접 조작하여 코드를 작성하던 '도구 보조(Tool-Assisted)' 시대를 지나, 다수의 특화된 AI 에이전트들이 협업하여 소프트웨어 생명주기를 주도하는 '에이전트 중심(Agent-Centric)' 생태계로 진입하고 있다. 이러한 변화는 단순한 생산성 향상을 넘어, 개발자의 역할을 '작성자(Writer)'에서 '설계자(Architect)'이자 '감독관(Supervisor)'으로 격상시킨다.
본 연구 보고서는 Google Antigravity, Anthropic Claude Code, Cursor IDE, 그리고 Visual Studio Code(VS Code)라는 현존하는 최상위 AI 개발 플랫폼들을 단일 프로젝트 루트 내에서 유기적으로 통합하는 '쿼드-하이브리드 개발 환경(Quad-Hybrid Development Environment, QHDE)' 아키텍처를 정의한다. 특히, 코딩 지식이 전무하거나 부족한 '시맨틱 아키텍트(Semantic Architect)'가 이러한 복잡한 다중 에이전트 시스템을 구축하고 운용할 수 있도록 하는 '부트스트랩 프로토콜(Bootstrap Protocol)'을 체계적으로 제시한다. 이 프로토콜은 AI에게 시스템의 설계도와 제약 조건을 자연어로 제시하여, 시스템 구동에 필요한 핵심 코드(오케스트레이터, 에이전트 브리지)를 AI 스스로 생성하게 만드는 메타 프롬프트 엔지니어링 전략을 포함한다.
본고에서는 15,000단어 분량의 심층 분석을 통해 폴리 에이전트 시스템의 물리적/경제적 기반이 되는 필수 자원(하드웨어, API 구독)을 정량적으로 산출하고, LangGraph와 MCP(Model Context Protocol) 기반의 오케스트레이션 서버를 노코드 방식으로 구현하는 구체적인 방법론을 다룬다.
________________
2. 폴리 에이전트 생태계의 이론적 배경과 QHDE 아키텍처
성공적인 오케스트레이션 환경을 구축하기 위해서는 각 도구가 가진 '인지적 특성'과 '시간적 작동 범위'를 이해하고 이를 아키텍처에 반영해야 한다. 이를 위해 본 연구는 '지연 시간 계층화(Latency Stratification)' 이론과 '기능적 장기(Organ)'로서의 도구론을 전개한다.
2.1 지연 시간 계층화 이론 (Latency Stratification Theory)
다중 에이전트 시스템의 효율성은 각 에이전트가 처리하는 작업의 시간적 호흡(Time Horizon)을 얼마나 잘 분리하느냐에 달려 있다. 모든 에이전트가 실시간 반응을 요구한다면 시스템은 경합 조건(Race Condition)에 빠지게 된다.1
계층 (Stratum)
	시간적 범위
	담당 에이전트
	인지적 역할 (Cognitive Role)
	주요 작업 유형
	즉시성 (Real-time)
	< 1초
	Cursor / VS Code
	인터랙티브 리드 개발자
	인간의 의도 파악, 실시간 코드 완성, 문맥적 제안
	배치성 (Batch)
	수 분 (Minutes)
	Claude Code
	헤드리스 DevOps 엔지니어
	대규모 리팩토링, 린팅, 테스트 자동화, Git 운영
	장기성 (Long-term)
	수 시간 (Hours)
	Google Antigravity
	프로젝트 아키텍트
	거시적 계획 수립, 요구사항 분석, 비동기 리서치
	이러한 계층화는 개발자가 "기다리는 시간"을 제거한다. 리팩토링이 필요할 때 개발자는 작업을 멈추고 기다리는 대신, Claude Code에게 작업을 위임하고 즉시 다른 창조적인 작업(Cursor)으로 전환할 수 있다.1
2.2 쿼드-하이브리드 개발 환경 (QHDE)의 구성 요소
QHDE 아키텍처는 네 가지 도구를 상호 보완적인 기능적 장기로 해석한다.
1. Google Antigravity (The Architect): 프로젝트의 '대뇌 피질' 역할을 수행한다. Gemini 3 Pro 모델의 긴 컨텍스트 윈도우를 활용하여 프로젝트 전체의 구조를 분석하고, 작업을 하위 태스크로 분할하여 계획서(Artifacts)를 생성한다.2
2. Claude Code (The Operator): 프로젝트의 '손과 발' 역할을 수행한다. 터미널 기반의 CLI 환경에서 작동하며, 파일 시스템 조작과 쉘 명령어 실행에 최적화된 'Unix 철학'을 따른다. 특히 UI 없이 백그라운드에서 작동하는 '헤드리스 모드(Headless Mode)'는 자동화의 핵심이다.1
3. Cursor (The Interface): 프로젝트의 '언어 중추'이자 인간과의 접점이다. 인간의 자연어 의도를 구체적인 코드로 변환하며, 'Vibe Coding'이라 불리는 몰입형 개발 경험을 제공한다.1
4. Visual Studio Code (The Specialist): 프로젝트의 '정밀 수술 도구'이다. AI가 해결하지 못하는 복잡한 충돌 해결이나 레거시 디버깅을 위해, AI 기능을 배제한 순수한 형태의 워크벤치로 사용된다.1
________________
3. 필수 자원 프로비저닝: 물리적, 경제적 기반 구축
폴리 에이전트 시스템은 단순한 소프트웨어가 아니라, 지속적으로 연산을 수행하고 데이터를 교환하는 하나의 '디지털 데이터 센터'이다. 따라서 이를 지탱하기 위한 하드웨어와 API 구독 모델에 대한 정밀한 설계가 선행되어야 한다.
3.1 하드웨어 요구사항: 병렬 처리와 메모리 아키텍처
다중 에이전트 오케스트레이션의 핵심은 **동시성(Concurrency)**이다. 사용자가 Cursor에서 코드를 작성하는 동안, 백그라운드에서는 Claude Code가 수십 개의 파일을 수정하고, Antigravity가 브라우저를 띄워 테스트를 수행한다. 이는 일반적인 개발 환경과는 차원이 다른 시스템 부하를 발생시킨다.
3.1.1 메모리 (RAM): 다중 섀도우 워크스페이스의 비용
가장 중요한 자원은 RAM이다. 각 에이전트는 자신만의 '세계'를 유지하기 위해 별도의 프로세스와 캐시를 점유한다.
* 섀도우 워크스페이스 (Shadow Workspace): 에이전트가 메인 에디터를 방해하지 않고 작업하기 위해 백그라운드에서 실행하는 독립적인 파일 시스템 인스턴스이다. VS Code나 Cursor 기반의 섀도우 워크스페이스 하나당 약 2~4GB의 메모리를 점유한다.1
* 언어 서버 프로토콜 (LSP): Python, TypeScript 등의 언어 분석을 위한 LSP가 에이전트 수만큼 중복 실행될 수 있다.
* 권장 사양:
   * 최소: 32GB. 이는 Cursor(메인)와 Claude Code(백그라운드) 2개 정도를 구동할 때의 마지노선이다.5
   * 권장: 64GB 이상. Antigravity(Java 기반 무거운 런타임), Cursor, 로컬 Docker 컨테이너(DB, MCP 서버), 브라우저 자동화 도구를 동시에 띄우기 위해서는 64GB가 필수적이다. 96GB 이상일 경우 스왑(Swap) 없이 쾌적한 에이전트 전환이 가능하다.7
3.1.2 프로세서 (CPU): 코어 수와 스레드 관리
GPU보다는 CPU의 코어(Core) 수가 중요하다. 에이전트 오케스트레이션은 거대 언어 모델(LLM)의 로컬 추론보다는 클라우드 API 호출과 로컬 파일 I/O 처리가 주를 이루기 때문이다.
* I/O 처리량: 수천 개의 파일을 동시에 읽고 쓰는 리팩토링 작업 시 inotify와 같은 파일 시스템 이벤트 감시자가 폭주할 수 있다. 이를 처리하기 위해서는 멀티코어 성능이 뛰어난 Apple M3 Max/Ultra 또는 AMD Ryzen 9 시리즈가 유리하다.8
3.1.3 스토리지 (Storage): 초고속 I/O
에이전트가 1초에 수백 개의 파일을 수정하는 상황에서 디스크 I/O가 병목이 되면 시스템 전체가 멈춘다(Freeze). PCIe 4.0 이상의 NVMe SSD(읽기/쓰기 7,000MB/s 이상)가 필수적이다.
3.2 구독 경제학: API 및 서비스 비용 분석
에이전트 노동력은 공짜가 아니다. 각 에이전트에게 최고의 지능을 제공하기 위해서는 적절한 구독과 API 티어(Tier) 설정이 필요하다. 단순한 'Pro' 요금제 하나로는 부족하며, 이를 '디지털 직원의 급여'로 인식해야 한다.
3.2.1 필수 구독 포트폴리오


구성 요소
	서비스 공급자
	필수 플랜
	예상 월 비용
	전략적 정당성
	미션 컨트롤
	Cursor IDE
	Business / Pro+
	$40 - $200
	일반 Pro($20) 플랜은 o1-preview와 같은 고지능 모델의 사용량이 제한적이다. 아키텍처 설계를 담당하는 Cursor에게는 무제한에 가까운 추론 능력이 필요하다.10
	DevOps 에이전트
	Anthropic (Claude)
	Team / API (Tier 2+)
	사용량 기반 ($100+)
	Claude Code CLI는 매우 빠른 속도로 토큰을 소모한다. 월 $20의 개인 플랜은 API 호출 제한(Rate Limit)에 금방 도달한다. Build Tier 2 이상의 API 키를 사용하여 분당 토큰 제한을 해제해야 한다.12
	매크로 플래너
	Google Antigravity
	Gemini Advanced
	$20 - $30
	200만 토큰 이상의 긴 컨텍스트 윈도우를 활용하여 프로젝트 전체를 이해하기 위해서는 Gemini 1.5 Pro 이상의 모델 접근권이 필수이다.2
	리서치 도구
	Brave Search API
	Paid Tier
	~$10
	에이전트가 최신 라이브러리 문서를 검색하여 환각(Hallucination)을 방지하려면 분당 수십 회의 검색이 가능한 유료 API가 필요하다.15
	합계
	

	

	월 $250 - $500
	이는 주니어 개발자 한 명을 고용하는 비용의 10% 미만으로, 3-4명의 전문가 에이전트를 운용하는 비용이다.
	3.2.2 숨겨진 비용: 무한 루프와 토큰 소각
자율 에이전트의 가장 큰 리스크는 오류 수정 과정에서 발생하는 **무한 루프(Infinite Loop)**다. 에이전트가 빌드 오류를 고치기 위해 코드를 수정하고, 그 수정이 또 다른 오류를 낳는 과정이 반복되면 하룻밤 사이에 수백 달러의 API 비용이 발생할 수 있다.16
* 대응 전략: 모든 에이전트 호출 시 --max-turns 플래그를 사용하여 실행 횟수를 강제로 제한해야 한다.1 또한 클라우드 콘솔에서 일일 예산 한도(Hard Budget Cap)를 설정하는 것이 필수적이다.
3.3 식별 및 접근 관리 (API 키 발급)
오케스트레이터가 에이전트들을 호출하기 위해서는 다음과 같은 API 키를 발급받아 환경 변수로 관리해야 한다.
1. ANTHROPIC_API_KEY: Claude Code를 헤드리스 모드로 구동하기 위한 핵심 키. Anthropic Console에서 'Service Account'용으로 별도 발급받는 것을 권장한다.
2. GEMINI_API_KEY: Google AI Studio에서 발급하며, Antigravity의 추론 엔진과 오케스트레이터의 분류 로직에 사용된다.
3. BRAVE_API_KEY: MCP 기반의 웹 검색 도구(@modelcontextprotocol/server-brave-search)를 구동하기 위해 필요하다.1
________________
4. 메타 오케스트레이터 아키텍처: 시스템의 두뇌 구축
이제 물리적 자원이 준비되었으므로, 이들을 하나로 묶는 논리적 아키텍처를 구축해야 한다. 코딩을 못하는 사용자를 위해, 우리는 AI에게 이 시스템을 구축하도록 지시하는 **'부트스트랩 프로토콜'**을 사용할 것이다.
4.1 메타 오케스트레이터의 역할
메타 오케스트레이터는 프로젝트 루트에서 실행되는 경량 Python 서버이다. 이 서버는 직접 코드를 작성하지 않고, LangGraph라는 라이브러리를 사용하여 사용자의 요청을 분석하고 적절한 에이전트에게 작업을 라우팅(Routing)하는 교환원 역할을 한다.1
* 상태 머신 (State Machine): 프로젝트의 상태(계획 단계, 실행 단계, 오류 수정 단계)를 추적한다.
* 라우터 (Router): "리팩토링해줘"라는 요청이 오면 Claude에게, "기획해줘"라는 요청이 오면 Antigravity에게 작업을 할당한다.
4.2 신경망: 모델 컨텍스트 프로토콜 (MCP)
서로 다른 회사(Google, Anthropic)의 에이전트들이 소통하기 위해 MCP라는 공통 표준을 사용한다.
* MCP 브리지: 오케스트레이터는 MCP를 통해 파일 시스템을 읽고, 다른 에이전트에게 명령을 내린다. 예를 들어, Antigravity가 작성한 계획서 파일을 Claude에게 전달하여 실행하게 하는 식이다.1
________________
5. 부트스트랩 프로토콜: AI를 이용한 시스템 생성 전략
코딩 지식이 없는 사용자가 이 복잡한 시스템을 구축하는 유일한 방법은 **"AI에게 시키는 법"**을 마스터하는 것이다. 이를 **메타 프롬프트(Meta-Prompting)**라고 하며, 코드 자체가 아니라 **'요구사항 명세서'**를 프롬프트로 입력하여 코드를 생성하게 하는 전략이다.
다음은 3단계로 구성된 구체적인 부트스트랩 전략이다.
5.1 1단계: 환경 설정 및 의존성 설치 (Environment Bootstrapping)
첫 번째 장벽은 Python과 Node.js 환경을 설정하는 것이다. 사용자는 터미널 명령어조차 낯설 수 있다.
전략: 운영체제(OS)를 명시하고, '복사-붙여넣기'만 하면 되는 설치 스크립트를 요청한다.
프롬프트 (환경 설정용):
역할: 당신은 초보자를 위한 친절한 시스템 관리자입니다.
목표: 내 컴퓨터(Windows 11/Mac M3)에서 '폴리 에이전트 오케스트레이션' 환경을 구축하기 위한 설치 스크립트를 작성해주세요.
요구사항:
1. Python 3.11 이상과 Node.js 18 이상이 설치되어 있는지 확인하고, 없으면 설치하는 명령어를 포함하세요.
2. 다음 Python 라이브러리를 설치하는 명령어를 작성하세요: langgraph, langchain, fastapi, uvicorn, python-dotenv.
3. 다음 MCP 관련 npm 패키지를 전역으로 설치하는 명령어를 작성하세요: @modelcontextprotocol/server-filesystem, @agentdeskai/browser-tools-mcp.
4. 프로젝트 폴더 구조(my-agentic-project)를 생성하고 그 안으로 이동하는 명령어를 포함하세요.
출력: 설명과 함께 터미널에 복사해서 붙여넣기만 하면 되는 단일 스크립트 코드 블록을 제공하세요.
인사이트: 이 프롬프트는 사용자가 개별 패키지의 버전을 고민할 필요 없이19에서 식별된 필수 패키지들을 한 번에 설치하도록 유도한다.
5.2 2단계: 오케스트레이터 서버 생성 (The Brain)
가장 중요한 server.py를 생성하는 단계이다. LangGraph의 로직을 사용자가 이해할 필요는 없다. 대신 로직의 **흐름(Flow)**을 명세해야 한다.
프롬프트 (오케스트레이터 생성용):
역할: 당신은 LangGraph와 Python 전문 수석 소프트웨어 아키텍트입니다.
목표: server.py라는 이름의 메타 오케스트레이터 에이전트 코드를 작성해주세요. 이 코드는 로컬에서 실행되며 Claude Code, Antigravity, Cursor 간의 작업을 조율합니다.
기술적 명세 (Specification):
   1. 상태 정의: ProjectState 클래스를 정의하고 task_description(작업 내용), assigned_agent(할당된 에이전트) 필드를 포함하세요.
   2. 분류 로직 (Router): classify_task 함수를 구현하여 다음 규칙에 따라 에이전트를 선택하게 하세요:
   * 작업 내용에 "리팩토링", "수정", "CLI"가 있으면 -> claude_agent
   * 작업 내용에 "계획", "검증", "설계"가 있으면 -> antigravity_agent
   * 그 외의 경우 -> cursor_human_handoff
   3. 실행 노드 (Nodes):
   * trigger_claude: 파이썬의 subprocess 모듈을 사용하여 쉘 명령어로 claude -p [작업내용] --output-format json을 실행하고 결과를 반환하는 함수를 작성하세요. 이것이 '헤드리스 모드'입니다.
   * notify_antigravity: .antigravity/plans/ 폴더에 작업 내용을 마크다운 파일로 저장하는 함수를 작성하세요.
   4. 워크플로우 구성: 위 함수들을 StateGraph로 연결하고 컴파일하는 코드를 작성하세요.
출력: 주석이 완벽하게 달린, 실행 가능한 전체 Python 코드를 제공하세요.
분석: 이 프롬프트는 1에서 추출한 Python 오케스트레이터의 핵심 로직을 자연어로 풀어낸 것이다. 사용자는 이 프롬프트를 입력함으로써 복잡한 LangGraph 상태 머신 코드를 얻을 수 있다.
5.3 3단계: 에이전트 브리지 연결 (The Nervous System)
마지막으로, 생성된 오케스트레이터와 다른 도구들을 연결하는 설정 파일 mcp_config.json을 생성해야 한다.
프롬프트 (MCP 설정 생성용):
역할: MCP(Model Context Protocol) 시스템 통합 전문가입니다.
목표: 내 프로젝트의 도구들을 연결하는 mcp_config.json 설정 파일을 생성해주세요.
설정 내용:
      1. 오케스트레이터 서버: 이름은 orchestrator, 실행 명령어는 python server.py입니다. 환경 변수로 ANTHROPIC_API_KEY와 GEMINI_API_KEY를 전달해야 합니다.
      2. 파일 시스템 서버: 이름은 filesystem, 실행 명령어는 npx를 사용해 @modelcontextprotocol/server-filesystem을 실행하며, 현재 폴더(./)에 대한 접근 권한을 부여합니다.
      3. Claude 브리지: 이름은 claude-bridge, 실행 명령어는 claude이며 인수로는 -p와 --mcp-config./mcp_config.json을 사용하여 재귀적으로 자신을 호출할 수 있게 설정하세요.
출력: 문법 오류가 없는 완벽한 JSON 코드를 제공하세요.
인사이트: 이 설정은 1에 명시된 MCP 서버 정의를 구현하며, 특히 Claude가 스스로를 도구로 호출할 수 있는 '재귀적 브리지' 구성을 포함한다.
5.4 4단계: 거버넌스 및 헌법 제정 (Governance Layer)
에이전트가 폭주하지 않도록 제약 조건을 거는 CLAUDE.md와 .cursorrules 파일을 생성한다.
프롬프트 (규칙 생성용):
역할: AI 윤리 및 시스템 안정성 담당 CTO입니다.
목표: 에이전트들의 행동 강령을 정의하는 두 개의 파일을 생성해주세요.
파일 1: CLAUDE.md (DevOps 에이전트용)
         * 페르소나: "시니어 SRE(사이트 신뢰성 엔지니어)"
         * 절대 규칙: rm, destroy, drop 같은 파괴적인 명령어는 env=prod 태그가 있는 리소스에 대해 절대 실행 금지.
         * 절차: 모든 변경 작업 전 반드시 plan 명령어를 먼저 실행하고 결과를 분석할 것.
파일 2:.cursorrules (리드 개발자용)
         * 페르소나: "까다로운 수석 아키텍트"
         * 행동: Claude나 Antigravity가 작성한 코드를 무조건 신뢰하지 말고, 보안 취약점과 성능 저하 가능성을 엄격하게 검토할 것.
         * 문맥: 항상 .antigravity/plans/ 폴더를 먼저 읽어서 전체 프로젝트의 진행 상황을 파악할 것.
출력: 두 파일의 내용을 마크다운 형식으로 구분하여 출력하세요.
________________
6. 운영 시나리오: 부트스트랩 이후의 워크플로우
위의 과정을 통해 시스템이 구축되면, 사용자는 코드를 작성하는 대신 **'지시(Directing)'**를 통해 개발을 진행한다.
6.1 기획 및 설계 (Antigravity -> Orchestrator)
사용자가 Antigravity의 매니저 서피스에 *"JWT 인증 시스템을 설계하고 구현해줘"*라고 입력한다.
         1. Antigravity 에이전트가 brave-search MCP를 통해 최신 보안 트렌드를 조사한다.
         2. 조사 결과를 바탕으로 .antigravity/plans/AUTH_PLAN.md에 상세 구현 계획(DB 스키마, API 엔드포인트)을 작성한다.1
         3. 백그라운드에서 실행 중이던 server.py(오케스트레이터)가 파일 생성을 감지하고, 계획서 내용을 읽어 분석한다.
6.2 실행 및 구현 (Orchestrator -> Claude Code)
         1. 오케스트레이터는 계획서의 내용이 "구현(Implementation)" 단계임을 인식하고, claude-bridge를 통해 Claude Code를 호출한다.
         2. 명령어: claude -p "AUTH_PLAN.md를 읽고 1단계: DB 스키마 코드를 작성하라" --dangerously-skip-permissions.1
         3. Claude Code는 터미널에서 백그라운드로 실행되며, 필요한 패키지를 설치하고 Python 모델 코드를 작성한 뒤 Git 커밋을 수행한다. 이 과정은 사용자에게 보이지 않는다(Headless).
6.3 검토 및 승인 (Cursor -> Human)
         1. 모든 작업이 완료되면 Claude는 .claude/outbox/done.json을 생성한다.
         2. Cursor IDE(리드 개발자 모드)는 이 파일을 감지하고, 사용자에게 알림을 보낸다. "Claude가 인증 모듈 구현을 완료했습니다. 코드를 검토하시겠습니까?"
         3. 사용자는 Cursor의 Diff 뷰를 통해 변경 사항을 확인하고, "승인" 버튼을 누르거나 자연어로 *"보안 토큰 만료 시간을 30분으로 줄여줘"*라고 수정 지시를 내린다.1
________________
7. 리스크 관리 및 문제 해결
노코드 사용자가 겪을 수 있는 주요 문제와 해결 방안을 미리 준비해야 한다.
7.1 무한 루프 방지 (Economic Kill-Switch)
에이전트끼리 서로 오류를 유발하며 무한히 수정 작업을 반복할 수 있다.
         * 해결책: server.py 생성 시 프롬프트에 *"모든 에이전트 호출 시 최대 재시도 횟수를 5회로 제한하는 로직을 포함하라"*는 지시를 추가한다. 또한 Anthropic 콘솔에서 월 예산 한도(Budget Cap)를 설정하여 요금 폭탄을 방지한다.13
7.2 파일 충돌 방지 (Semaphore)
Claude와 Antigravity가 동시에 같은 파일을 수정하려 할 수 있다.
         * 해결책: 오케스트레이터가 작업을 할당할 때 해당 디렉토리에 .agent_lock 파일을 생성하게 한다. rules.md에는 *"락 파일이 존재하면 작업을 멈추고 대기하라"*는 지침이 포함되어야 한다.1
________________
8. 결론: 시맨틱 아키텍트의 탄생
본 보고서에서 제시한 QHDE 아키텍처와 부트스트랩 프로토콜은 코딩 능력이 없는 사용자도 최첨단 AI 에이전트 군단을 자신의 손발처럼 부릴 수 있게 한다. 64GB 이상의 메모리와 적절한 API 구독이라는 자본적 투입, 그리고 AI에게 시스템 구축을 위임하는 메타 프롬프트 전략을 통해, 사용자는 '개발자'를 넘어선 '시맨틱 아키텍트'로 거듭날 수 있다.
이제 소프트웨어 개발은 '어떻게(How)' 구현할 것인가의 문제에서 '무엇을(What)' 만들 것인가의 문제로 완전히 이동했다. 이 보고서가 그 새로운 여정의 지침서가 되기를 바란다.
________________
인용 자료:
1 AI 도구 통합 개발 환경 연구.txt
1 Claude Code 오케스트레이션 연구.txt
1 Cursor와 폴리 에이전트 오케스트레이션 통합.txt
1 VS Code 폴리 에이전트 오케스트레이션 설정.txt
1 폴리 에이전트 오케스트레이션 Antigravity 연구.txt
2 하드웨어 사양, 비용, MCP 관련 웹 검색 정보.
참고 자료
         1. AI 도구 통합 개발 환경 연구.txt
         2. How to Set Up and Use Google Antigravity - Codecademy, 12월 22, 2025에 액세스, https://www.codecademy.com/article/how-to-set-up-and-use-google-antigravity
         3. Claude Code — Tutorial. A command line tool for agentic coding. | by Sweety Tripathi | 𝐀𝐈 𝐦𝐨𝐧𝐤𝐬.𝐢𝐨, 12월 22, 2025에 액세스, https://medium.com/aimonks/claude-code-tutorial-80037240aaab
         4. Cursor 2.0 - Full Tutorial for Beginners, 12월 22, 2025에 액세스, https://www.youtube.com/watch?v=l30Eb76Tk5s
         5. How Much RAM Do I Need? A Comprehensive Guide - Lexar, 12월 22, 2025에 액세스, https://americas.lexar.com/how-much-ram-do-i-need/
         6. Users with 32GB+ RAM: What are your applications to justify 32GB, 64GB or more of RAM? : r/linuxquestions - Reddit, 12월 22, 2025에 액세스, https://www.reddit.com/r/linuxquestions/comments/paiubs/users_with_32gb_ram_what_are_your_applications_to/
         7. HUB - How Much RAM Do Gamers Need? 16GB vs. 32GB vs. 64GB : r/hardware - Reddit, 12월 22, 2025에 액세스, https://www.reddit.com/r/hardware/comments/1dio4kj/hub_how_much_ram_do_gamers_need_16gb_vs_32gb_vs/
         8. How much RAM is required for an AI-powered laptop? - Box, 12월 22, 2025에 액세스, https://box.co.uk/blog/required-ram-for-ai-powered-laptop
         9. What are the Minimum Hardware Requirements for Artificial Intelligence?, 12월 22, 2025에 액세스, https://www.moontechnolabs.com/qanda/minimum-hardware-requirements-for-artificial-intelligence/
         10. Pricing - Cursor, 12월 23, 2025에 액세스, https://cursor.com/pricing
         11. Pricing | Cursor Docs, 12월 23, 2025에 액세스, https://cursor.com/docs/account/pricing
         12. Anthropic API Pricing: The 2026 Guide - nOps, 12월 22, 2025에 액세스, https://www.nops.io/blog/anthropic-api-pricing/
         13. Rate limits - Claude Docs, 12월 23, 2025에 액세스, https://platform.claude.com/docs/en/api/rate-limits
         14. Billing | Gemini API | Google AI for Developers, 12월 23, 2025에 액세스, https://ai.google.dev/gemini-api/docs/billing
         15. @modelcontextprotocol/server-brave-search | MCP Package Details & Installation Guide, 12월 23, 2025에 액세스, https://mcp-get.com/packages/%40modelcontextprotocol%2Fserver-brave-search
         16. How to Keep AI Agent Costs Predictable and Within Budget | Datagrid, 12월 22, 2025에 액세스, https://datagrid.com/blog/8-strategies-cut-ai-agent-costs
         17. The Hidden Cost of Agentic AI: Why Most Projects Fail Before Reaching Production, 12월 22, 2025에 액세스, https://galileo.ai/blog/hidden-cost-of-agentic-ai
         18. Creating Your First MCP Server: A Hello World Guide | by Gianpiero Andrenacci | AI Bistrot | Dec, 2025, 12월 22, 2025에 액세스, https://medium.com/data-bistrot/creating-your-first-mcp-server-a-hello-world-guide-96ac93db363e
         19. langchain-mcp-adapters - PyPI, 12월 23, 2025에 액세스, https://pypi.org/project/langchain-mcp-adapters/
         20. How to configure windows filesystem? · Issue #75 · modelcontextprotocol/servers - GitHub, 12월 23, 2025에 액세스, https://github.com/modelcontextprotocol/servers/issues/75