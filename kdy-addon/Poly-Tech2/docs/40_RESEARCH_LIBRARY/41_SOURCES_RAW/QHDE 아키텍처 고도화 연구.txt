연구 보고서 2.1: 폴리 에이전트 오케스트레이션(Poly-Agentic Orchestration)을 위한 커스텀 MCP(Model Context Protocol) 서버 개발 및 아키텍처 구현 심층 분석
1. 서론: 에이전트 네이티브(Agent-Native) 개발 환경의 도래와 연결성의 위기
소프트웨어 엔지니어링의 패러다임은 단순한 도구 활용(Tool-Assisted)의 단계를 넘어, 자율적인 AI 에이전트들이 주도적으로 코드를 생산하고 관리하는 에이전트 중심(Agent-Centric) 생태계로 급격히 진화하고 있습니다. 과거의 통합 개발 환경(IDE)이 인간 개발자의 입력을 보조하는 정적인 편집기였다면, 차세대 개발 환경은 다수의 전문화된 AI 에이전트들이 상호작용하며 복잡한 엔지니어링 과제를 수행하는 '디지털 작업장'으로 변모하고 있습니다.1 이러한 변화 속에서 개발자의 역할은 코드를 직접 작성하는 '저자(Author)'에서 에이전트 군단을 지휘하고 조율하는 '아키텍트(Architect)' 또는 '미션 컨트롤러(Mission Controller)'로 격상됩니다.1
그러나 현재의 기술적 환경은 각기 다른 인지 아키텍처와 실행 환경을 가진 도구들로 파편화되어 있습니다. Google의 Antigravity는 거시적인 계획 수립과 비동기 관리에 강점을 보이고, Anthropic의 Claude Code는 터미널 기반의 강력한 실행 능력을 갖추었으며, Cursor는 인간과의 실시간 상호작용에 최적화되어 있습니다.1 이들 도구가 단일 프로젝트 내에서 충돌 없이 협업하기 위해서는 단순한 API 연동을 넘어선, 이들의 인지 과정과 실행 맥락(Context)을 공유하고 제어할 수 있는 표준화된 '신경망'이 필수적입니다.
**Model Context Protocol (MCP)**는 바로 이러한 연결성의 위기를 해결하기 위해 등장한 개방형 표준입니다. MCP는 대규모 언어 모델(LLM)이 로컬 파일 시스템, 데이터베이스, 외부 도구와 소통하는 방식을 표준화함으로써, "AI를 위한 USB-C 포트"와 같은 역할을 수행합니다.2 하지만 시중의 범용 MCP 서버들은 단순한 데이터 접근 기능만을 제공할 뿐, 다중 에이전트 환경에서 필연적으로 발생하는 상태 기억 상실(Memory Amnesia), 자원 경합(Race Condition), 프로세스 고립(Process Isolation) 문제를 해결하지 못합니다.
본 연구 보고서는 이러한 한계를 극복하고, '폴리 에이전트 오케스트레이션'을 완벽하게 구현하기 위해 필요한 커스텀 MCP 서버 개발 방법론을 심층적으로 다룹니다. 우리는 프로젝트 메모리 서버(Project Memory Server), 파일시스템 게이트키퍼(FileSystem Gatekeeper), **에이전트 브리지(Agent Bridge)**라는 세 가지 핵심 커스텀 서버의 아키텍처를 제안하며, 이를 Python 기반의 FastMCP 프레임워크와 SQLite, 그리고 운영체제 수준의 프로세스 제어 기술을 통해 구현하는 구체적인 방안을 제시합니다. 이 연구는 단순한 코딩 가이드를 넘어, 미래 소프트웨어 개발의 표준이 될 '자율 운영 레포지토리(Self-Driving Repository)'의 청사진을 제공하는 것을 목적으로 합니다.
________________
2. 이론적 배경: 인지 계층화와 프로토콜 기반 거버넌스
2.1 지연 시간 계층화(Latency Stratification) 이론과 MCP의 역할
효율적인 폴리 에이전트 시스템을 설계하기 위해서는 각 에이전트의 작동 속도와 인지 깊이에 따른 계층화가 선행되어야 합니다. 본 연구는 에이전트의 역할을 즉시성(Real-time), 배치성(Batch), **장기성(Long-term)**의 세 가지 시간적 차원으로 분류하는 '지연 시간 계층화' 이론을 기반으로 합니다.1
계층 (Layer)
	대표 에이전트
	시간적 범위
	인지적 특성
	MCP 서버의 역할
	즉시성 (System 1)
	Cursor, VS Code
	< 1초
	직관적, 빠른 편집, 사용자 인터페이스
	실시간 컨텍스트 주입, 잠금 상태 확인
	배치성 (System 1.5)
	Claude Code
	수 분
	절차적, 터미널 실행, 반복 작업
	도구 실행 권한 위임, 실행 로그 기록
	장기성 (System 2)
	Google Antigravity
	수 시간
	계획적, 심층 추론(Deep Think), 검증
	전체 아키텍처 조망, 장기 기억 저장
	MCP는 이 서로 다른 시간대에서 작동하는 에이전트들을 연결하는 비동기식 메시지 버스(Asynchronous Message Bus) 역할을 수행합니다. 예를 들어, Antigravity가 수립한 '장기 계획'은 MCP 메모리 서버에 저장되어, 수 분 뒤에 실행될 Claude Code가 이를 참조할 수 있게 합니다. 이는 인간의 뇌에서 단기 기억이 해마를 거쳐 장기 기억으로 저장되는 과정과 유사하며, 커스텀 MCP 서버는 이러한 인지적 연결을 기술적으로 구현하는 핵심 장치입니다.
2.2 표준 프로토콜로서의 MCP 아키텍처
MCP는 클라이언트-호스트-서버 모델을 따릅니다.4
* MCP 호스트(Host): LLM을 구동하는 애플리케이션(예: Cursor, Claude Desktop, Antigravity IDE). 사용자의 입력을 받아 처리를 시작하는 주체입니다.
* MCP 클라이언트(Client): 호스트 내부에서 서버와의 통신을 담당하는 모듈입니다.
* MCP 서버(Server): 실제 자원(데이터베이스, 파일 시스템)에 접근하거나 도구(Tool)를 실행하는 독립적인 프로세스입니다.
본 연구에서 제안하는 커스텀 서버들은 표준 프로토콜 위에서 미들웨어(Middleware) 로서 기능합니다. 단순한 읽기/쓰기 요청을 그대로 수행하는 것이 아니라, 요청의 주체(Agent ID)를 식별하고, 권한을 검증하며, 작업의 상태를 추적하는 '지능형 레이어'를 프로토콜 단계에 주입하는 것입니다.5
2.3 mcp_config.json: 단일 진실 공급원(Single Source of Truth)
모든 에이전트가 동일한 환경과 규칙 아래서 작동하기 위해서는 중앙화된 설정 파일이 필요합니다. 프로젝트 루트에 위치한 mcp_config.json은 에이전트들에게 "무엇을 볼 수 있고, 무엇을 할 수 있는지"를 규정하는 헌법과 같습니다.1
이 설정 파일은 로컬 Python 스크립트 실행을 정의하며, 특히 uv나 poetry와 같은 현대적인 패키지 매니저를 사용하여 의존성을 격리하고 실행 속도를 최적화해야 합니다.6
표 1: 폴리 에이전트 환경을 위한 mcp_config.json 구조 설계


JSON




{
 "mcpServers": {
   "project-memory": {
     "command": "uv",
     "args": ["run", "python", "./tools/mcp/memory_server.py"],
     "env": {
       "DB_PATH": "${workspaceFolder}/.cursor/poly_agent_memory.db",
       "LOG_LEVEL": "INFO"
     }
   },
   "gatekeeper": {
     "command": "uv",
     "args": ["run", "python", "./tools/mcp/gatekeeper_server.py"],
     "env": {
       "ALLOWED_ROOT": "${workspaceFolder}",
       "PROTECTED_PATHS": ".github,.env, mcp_config.json"
     },
     "alwaysAllow": ["acquire_lock", "check_lock_status"]
   },
   "agent-bridge": {
     "command": "uv",
     "args": ["run", "python", "./tools/mcp/bridge_server.py"],
     "env": {
       "ANTHROPIC_API_KEY": "${env:ANTHROPIC_API_KEY}"
     },
     "alwaysAllow": ["dispatch_headless_task"]
   }
 }
}

위 설정에서 alwaysAllow 속성은 매우 중요합니다. 자율 에이전트가 백그라운드에서 작업을 수행할 때, 파일 잠금을 확인하거나 하위 에이전트를 호출하는 과정마다 인간의 승인을 기다린다면 비동기 작업의 효율성은 0으로 수렴합니다.7 따라서 시스템의 안정성을 해치지 않는 '조회' 및 '제어' 도구들은 명시적으로 승인 목록에 포함시켜야 합니다.
________________
3. 핵심 서버 I: 프로젝트 메모리 서버 (Project Memory Server) - 인지적 연속성의 구현
3.1 문제 제기: 에이전트의 기억 상실증
대부분의 AI 코딩 도구는 세션이 종료되면 기억을 잃습니다. Antigravity가 "인증 모듈을 JWT 기반으로 리팩토링하라"는 계획을 세웠더라도, 이 세션이 끝나고 Claude Code가 실행될 때 그 계획의 구체적인 '맥락(Context)'과 '제약 조건(Constraints)'은 전달되지 않습니다. 채팅 로그를 복사해 붙여넣는 방식은 토큰 비용을 낭비할 뿐만 아니라 구조화된 정보를 전달하는 데 한계가 있습니다.8
이를 해결하기 위해 우리는 SQLite 기반의 영속적 메모리 서버를 구축합니다. 벡터 데이터베이스(Vector DB)가 의미적 검색에 유리하다면, 관계형 데이터베이스(RDB)인 SQLite는 작업의 상태(Status), 의존성(Dependencies), 그리고 명확한 결정 사항(Decisions)을 구조적으로 저장하는 데 최적입니다.9
3.2 스키마 설계: 엔지니어링 프로세스의 데이터 모델링
프로젝트 메모리 서버는 단순한 텍스트 저장소가 아니라, 소프트웨어 개발 생명주기(SDLC)를 데이터로 표현하는 모델을 가져야 합니다.
핵심 엔티티 및 관계 정의:
1. agents (행위자): 시스템에 참여하는 에이전트와 인간의 식별 정보.
   * id: 에이전트 식별자 (예: antigravity-architect, claude-executor)
   * role: 역할 (Architect, Engineer, QA)
   * permissions: 허용된 도구 목록 (JSON)
2. tasks (작업): 수행해야 할 엔지니어링 과제. Antigravity가 생성하고 Claude가 수행합니다.
   * id: UUID
   * parent_id: 상위 작업 ID (작업 분해 지원)
   * description: 자연어 목표 기술
   * status: PENDING, IN_PROGRESS, COMPLETED, FAILED
   * assigned_to: 담당 에이전트 ID
   * artifacts_path: 결과물이 저장될 경로
3. decision_log (의사결정 기록): 프로젝트의 아키텍처 원칙과 기술적 결정을 기록. 이는 '헌법'과 같은 역할을 하여 에이전트의 표류(Drift)를 방지합니다.
   * id: UUID
   * topic: 주제 (예: "State Management")
   * decision: 결정 사항 (예: "Redux 대신 Zustand 사용")
   * rationale: 근거 (예: "보일러플레이트 감소 및 번들 사이즈 최적화")
4. context_fragments (지식 조각): 특정 작업에 필요한 코드 스니펫이나 문서 참조.
3.3 FastMCP를 이용한 서버 구현 (Python)
Python의 FastMCP 라이브러리는 데코레이터 패턴을 통해 이러한 데이터베이스 로직을 MCP 도구로 손쉽게 노출할 수 있게 해줍니다.10 Pydantic을 활용한 타입 정의는 LLM이 정확한 인자를 전달하도록 강제하는 데 필수적입니다.11


Python




from fastmcp import FastMCP
from pydantic import BaseModel, Field
import sqlite3
import json
from typing import Optional, List

# 서버 초기화 및 의존성 주입
mcp = FastMCP("ProjectMemory", dependencies=["sqlite3", "pydantic"])
DB_PATH = "./.cursor/poly_agent_memory.db"

# 데이터베이스 초기화 로직 (생략 가능, 실제 구현 시 필수)
def init_db():
   with sqlite3.connect(DB_PATH) as conn:
       conn.execute("""
           CREATE TABLE IF NOT EXISTS tasks (
               id TEXT PRIMARY KEY,
               objective TEXT NOT NULL,
               status TEXT DEFAULT 'PENDING',
               assigned_agent TEXT,
               created_at DATETIME DEFAULT CURRENT_TIMESTAMP
           )
       """)
       #... 기타 테이블 생성

# 입력 모델 정의 (Pydantic)
class TaskSchema(BaseModel):
   objective: str = Field(..., description="작업의 구체적인 목표")
   assigned_agent: str = Field("claude-auto", description="작업을 수행할 에이전트 ID")

@mcp.tool()
def create_task(task: TaskSchema) -> str:
   """
   새로운 엔지니어링 작업을 메모리에 등록합니다.
   Antigravity와 같은 기획 에이전트가 실행 계획을 수립할 때 호출합니다.
   """
   import uuid
   task_id = str(uuid.uuid4())
   with sqlite3.connect(DB_PATH) as conn:
       conn.execute(
           "INSERT INTO tasks (id, objective, assigned_agent) VALUES (?,?,?)",
           (task_id, task.objective, task.assigned_agent)
       )
   return f"Task created with ID: {task_id}"

@mcp.resource("memory://active_tasks")
def get_active_tasks() -> str:
   """
   현재 진행 중인 모든 작업을 JSON 형식으로 반환합니다.
   에이전트가 세션을 시작할 때 컨텍스트로 자동 주입되는 리소스입니다.
   """
   with sqlite3.connect(DB_PATH) as conn:
       conn.row_factory = sqlite3.Row
       cursor = conn.execute("SELECT * FROM tasks WHERE status = 'IN_PROGRESS'")
       tasks = [dict(row) for row in cursor.fetchall()]
   return json.dumps(tasks, indent=2)

if __name__ == "__main__":
   init_db()
   mcp.run()

3.4 컨텍스트 주입(Context Injection) 전략
위 코드에서 get_active_tasks는 @mcp.resource로 정의되었습니다. 이는 단순한 함수 호출이 아니라, 호스트 애플리케이션(Cursor 등)이 에이전트의 프롬프트 창에 "항상 띄워놓을 수 있는" 읽기 전용 데이터임을 의미합니다.8 Cursor의 설정에서 이 리소스를 구독하면, 인간 개발자나 AI 에이전트는 별도의 질의 없이도 현재 프로젝트의 진행 상황을 실시간으로 인지할 수 있습니다. 이는 "상태 비저장(Stateless)" 모델의 한계를 기술적으로 극복하는 강력한 방법입니다.
________________
4. 핵심 서버 II: 파일시스템 게이트키퍼 (FileSystem Gatekeeper) - 동시성 제어 및 보안
4.1 문제 제기: 자원 경합과 데이터 오염
폴리 에이전트 환경의 가장 치명적인 위험은 **경쟁 조건(Race Condition)**입니다.1
* 상황: 사용자가 Cursor에서 UserAuth.ts 파일을 수정하고 있습니다.
* 동시에: 백그라운드에서 실행된 Claude Code 에이전트가 린트(Lint) 오류를 수정하기 위해 동일한 UserAuth.ts 파일을 열고 수정 후 저장합니다.
* 결과: 사용자가 저장하는 순간 Claude의 수정 사항이 덮어씌워지거나, 반대로 사용자의 작업물이 유실됩니다.
기존의 OS 레벨 파일 잠금(File Locking)은 에디터 수준에서 무시되는 경우가 많으며, AI 에이전트에게 "파일이 잠겼으니 기다리라"는 의미론적 피드백을 주지 못합니다. 따라서 MCP 레벨에서 논리적 뮤텍스(Mutex)를 구현해야 합니다.
4.2 아키텍처: 의미론적 뮤텍스(Semantic Mutex)와 Agent_Lock 패턴
우리는 FileSystem Gatekeeper 서버를 통해 모든 파일 접근을 중개합니다. 이 서버는 내부적으로 file_locks 테이블(SQLite)을 유지하며, 파일 시스템에 물리적인 .agent_lock 파일을 생성하여 인간 개발자에게도 시각적 경고를 보냅니다.1
4.2.1 잠금 프로토콜 (Locking Protocol)
잠금 메커니즘은 Acquire(획득) -> Work(작업) -> Release(해제)의 엄격한 생명주기를 따릅니다.
1. 획득 (Acquire): 에이전트는 파일을 수정하기 전 반드시 acquire_lock(path) 도구를 호출해야 합니다.
   * 서버는 해당 경로가 이미 잠겨 있는지 확인합니다.
   * 잠겨 있다면 LockError와 함께 잠금 소유자 정보, 만료 예정 시간을 반환합니다. 에이전트는 이를 통해 "대기(Wait)"하거나 "다른 작업 수행(Back-off)"을 결정할 수 있습니다.
2. 검증 (Validation): Gatekeeper의 write_file 도구는 내부적으로 요청한 에이전트 ID가 해당 파일의 잠금을 소유하고 있는지 검사합니다. 잠금 없이 쓰기를 시도하면 요청은 거부됩니다.
3. 해제 (Release): 작업 완료 후 release_lock(path)을 호출하여 자원을 반환합니다.
4. 감시견 (Watchdog): 에이전트가 오류로 종료되어 잠금을 해제하지 못하는 상황(Deadlock)을 방지하기 위해, 백그라운드 스레드가 5분 이상 유지된 잠금을 강제로 해제하고 로그를 남깁니다.1
4.2.2 FastMCP 미들웨어를 통한 권한 제어
FastMCP의 미들웨어(Middleware) 기능을 활용하면, 도구 실행 전후에 보안 로직을 투명하게 주입할 수 있습니다.5


Python




from fastmcp import FastMCP, Context
from fastmcp.exceptions import ToolError
import time

mcp = FastMCP("Gatekeeper")

# 잠금 상태를 확인하는 미들웨어
@mcp.middleware("tool_call")
async def check_lock_middleware(ctx: Context, next_handler):
   tool_name = ctx.request.method
   agent_id = ctx.session.get("agent_id", "unknown")
   
   # 쓰기 작업인 경우 잠금 확인
   if tool_name in ["write_file", "apply_diff"]:
       path = ctx.request.params.get("path")
       if is_locked_by_other(path, agent_id):
           owner = get_lock_owner(path)
           raise ToolError(f"ACCESS DENIED: File '{path}' is locked by agent '{owner}'.")
           
   return await next_handler(ctx)

@mcp.tool()
def acquire_lock(path: str, agent_id: str, reason: str) -> str:
   """파일에 대한 독점적 수정 권한을 요청합니다."""
   if create_lock(path, agent_id, reason):
       # 인간 개발자를 위한 가시적 잠금 파일 생성 
       with open(f"{path}.agent_lock", "w") as f:
           f.write(f"LOCKED BY {agent_id}: {reason}")
       return "Lock acquired successfully."
   else:
       return "Lock failed: Already locked."

4.3 보안 샌드박싱과 에이전트 표류(Drift) 방지
에이전트가 의도치 않게 프로젝트 범위를 벗어난 파일(예: /etc/passwd 또는 상위 디렉토리)을 수정하거나, 민감한 설정 파일(.env)을 건드리는 것을 방지해야 합니다. Gatekeeper 서버는 경로 유효성 검사(Path Validation) 로직을 내장하여, 모든 파일 접근이 프로젝트 루트(allowed_root_path) 내에서만 이루어지도록 강제합니다.13 또한, mcp_config.json의 환경 변수를 통해 READ_ONLY_PATHS 목록을 주입받아 특정 파일의 수정을 원천적으로 차단할 수 있습니다.
________________
5. 핵심 서버 III: 에이전트 브리지 (Agent Bridge) - 이기종 에이전트 간 통신
5.1 인지적 격차(Cognitive Gap)와 연결의 필요성
Antigravity(Architect)는 계획 수립 능력은 뛰어나지만, 로컬 터미널 제어 능력은 제한적입니다. 반면 Claude Code(Engineer)는 CLI 환경에서 강력한 실행 능력을 가지지만, 장기적인 맥락 유지에 약점이 있습니다. 이 두 에이전트는 서로 다른 '언어'와 '인터페이스'를 사용하므로 직접적인 통신이 불가능합니다. Agent Bridge 서버는 이 간극을 메우는 번역기이자 라우터입니다.
5.2 헤드리스(Headless) 실행 패턴 구현
Agent Bridge는 Claude Code CLI를 하위 프로세스(Subprocess)로 실행하고, 그 입출력을 구조화된 JSON 데이터로 변환하여 Antigravity에게 전달합니다. 이를 위해 Claude Code의 '헤드리스 모드' 플래그들을 적극 활용합니다.1
주요 CLI 플래그 전략:
* -p "prompt": 대화형 모드 대신 단일 프롬프트를 실행하고 종료합니다.
* --dangerously-skip-permissions: 자율 실행의 핵심입니다. 에이전트가 terraform apply와 같은 명령어를 실행할 때 인간의 승인을 기다리며 무한 대기(Hanging)하는 것을 방지합니다. 물론 이는 샌드박스 환경 내에서만 허용되어야 합니다.1
* --output-format json: 실행 결과를 기계가 파싱 가능한 형태로 반환받아, Antigravity가 성공/실패 여부를 논리적으로 판단할 수 있게 합니다.
5.3 아티팩트 기반 핸드오프(Artifact-Based Handoff) 프로토콜
직접적인 메시지 전달은 복잡한 컨텍스트를 잃어버릴 위험이 있습니다. 따라서 Agent Bridge는 **아티팩트(Artifact)**를 매개로 한 통신 방식을 채택합니다.1
1. Antigravity (지시): "인증 모듈 리팩토링"이라는 작업을 위해 create_task_artifact 도구를 호출합니다. 이는 .antigravity/plans/task_auth.md 파일을 생성합니다.
2. Agent Bridge (중계): 파일 생성을 감지하거나 호출을 받으면, Claude Code를 실행하며 해당 아티팩트의 경로를 컨텍스트로 주입합니다.
   * 명령어 예시: claude -p "Read.antigravity/plans/task_auth.md and execute the plan."...
3. Claude Code (실행): 작업을 수행하고 결과 리포트를 .antigravity/artifacts/result_auth.json으로 저장합니다.
4. Antigravity (검토): Bridge로부터 작업 완료 신호를 받고, 결과 JSON을 읽어 성공 여부를 검증합니다.


Python




import subprocess
from fastmcp import FastMCP

mcp = FastMCP("AgentBridge")

@mcp.tool()
def dispatch_devops_task(instruction: str, context_files: list[str]) -> str:
   """
   DevOps 작업을 헤드리스 Claude Code 에이전트에게 위임합니다.
   """
   # 보안 및 자동화를 위한 플래그 조합 
   cmd = [
       "claude", 
       "-p", instruction,
       "--dangerously-skip-permissions", 
       "--output-format", "json"
   ]
   
   # 하위 프로세스 실행
   result = subprocess.run(cmd, capture_output=True, text=True)
   
   # 결과를 프로젝트 메모리에 로그로 남김 (Log to Memory)
   log_handoff_event("Antigravity", "Claude", instruction, result.stdout)
   
   return result.stdout

________________
6. 통합 및 구현 전략
6.1 rules.md와 CLAUDE.md: 시스템 헌법의 제정
커스텀 서버들이 기술적인 '근육'이라면, 이를 올바르게 사용하는 '지능'은 프롬프트 규칙 파일에 정의됩니다. 각 에이전트가 커스텀 도구를 언제, 어떻게 사용해야 하는지를 명시하는 헌법(Constitution) 파일이 필요합니다.1
CLAUDE.md / .cursorrules 필수 포함 내용:
* Protocol 1 (Memory First): 작업을 시작하기 전 반드시 project-memory를 조회하여 중복 작업을 방지하고 이전 결정을 숙지할 것.
* Protocol 2 (Lock Before Write): 파일을 수정하기 전 반드시 gatekeeper.acquire_lock을 호출할 것. 실패 시 대기하거나 다른 작업을 수행할 것.
* Protocol 3 (Delegation): 10개 이상의 파일을 수정하거나 시스템 명령어가 필요한 경우, 직접 수행하지 말고 agent-bridge를 통해 전문 에이전트에게 위임할 것.
6.2 배포 및 운영 시나리오
이 시스템을 실제 프로젝트에 적용하기 위해서는 다음과 같은 단계적 도입이 권장됩니다.
1. 설치: 프로젝트 루트에 ./tools/mcp/ 디렉토리를 생성하고 Python 스크립트들을 배치합니다. pyproject.toml에 fastmcp, pydantic 등의 의존성을 정의합니다.
2. 등록: mcp_config.json에 로컬 경로를 등록합니다. 이때 uv를 사용하여 가상 환경 설정 없이도 즉시 실행되도록 구성합니다.1
3. 검증: MCP Inspector 도구를 사용하여 각 서버의 도구들이 정상적으로 호출되고, 데이터베이스에 상태가 저장되는지 단위 테스트를 수행합니다.15
운영 시나리오: "심층 리팩토링(Deep Refactor)"
* 사용자: "전체 프로젝트의 로깅 라이브러리를 winston으로 교체해줘."
* Antigravity: project-memory를 조회해 관련 파일 목록을 파악하고, 계획 아티팩트를 작성합니다.
* Antigravity -> Agent Bridge: "이 계획대로 실행해"라며 Claude Code를 호출합니다.
* Claude Code: gatekeeper를 통해 수정할 파일들에 대해 일괄 잠금(Batch Lock)을 요청합니다.
* Gatekeeper: 잠금을 승인하고 .agent_lock 파일을 생성하여 인간 개발자가 해당 파일을 건드리지 않도록 경고합니다.
* Claude Code: 파일을 수정하고 테스트를 실행한 뒤, 잠금을 해제하고 결과 리포트를 작성합니다.
* Antigravity: 결과를 확인하고 사용자에게 완료를 보고합니다.
________________
7. 결론 및 향후 전망: 자율 수정 레포지토리의 시작
본 연구에서 제안한 커스텀 MCP 서버 아키텍처는 단순한 도구의 확장이 아니라, 소프트웨어 레포지토리를 능동적인 유기체로 전환하는 시도입니다.
프로젝트 메모리 서버는 프로젝트에 시간의 흐름에 따른 맥락을 부여하여 에이전트가 과거의 실수를 반복하지 않게 합니다. 파일시스템 게이트키퍼는 다중 지성체(Multi-Intelligence)가 공존할 수 있는 질서를 부여합니다. 에이전트 브리지는 이질적인 AI 모델들을 하나의 팀으로 묶어주는 언어적 가교 역할을 합니다.
이러한 인프라 위에서 개발자는 더 이상 코드 한 줄 한 줄을 검수하는 관리자가 아니라, 시스템의 목적 함수(Objective Function)를 설계하는 진정한 의미의 아키텍트가 될 수 있습니다. 향후 MCP 생태계가 확장됨에 따라, 이러한 커스텀 서버들은 CI/CD 파이프라인, 클라우드 인프라 관리, 보안 감사 시스템과 결합되어 **'자율 주행 데이터 센터(Self-Driving Data Center)'**의 핵심 두뇌로 진화할 것입니다. 이제 코드는 사람이 짜는 것이 아니라, 사람이 설계한 시스템이 짜는 시대가 도래했습니다.
________________
참고 문헌:


1
참고 자료
1. Cursor와 폴리 에이전트 오케스트레이션 통합.txt
2. Building Your Own MCP Server with FastMCP | by Alaa Dania Adimi | InfinitGraph | Nov, 2025, 12월 23, 2025에 액세스, https://medium.com/infinitgraph/building-your-own-mcp-server-with-fastmcp-7d9cc73a1062
3. What is Model Context Protocol (MCP)? A guide | Google Cloud, 12월 23, 2025에 액세스, https://cloud.google.com/discover/what-is-model-context-protocol
4. Specification - Model Context Protocol, 12월 23, 2025에 액세스, https://modelcontextprotocol.io/specification/2025-06-18
5. MCP Middleware - FastMCP, 12월 23, 2025에 액세스, https://gofastmcp.com/servers/middleware
6. Build an MCP client - Model Context Protocol, 12월 23, 2025에 액세스, https://modelcontextprotocol.io/docs/develop/build-client
7. Connect to local MCP servers - Model Context Protocol, 12월 23, 2025에 액세스, https://modelcontextprotocol.io/docs/develop/connect-local-servers
8. MCP: Memory and State Management. This article is part 3 of my… | by Parichay Pothepalli, 12월 23, 2025에 액세스, https://medium.com/@parichay2406/mcp-memory-and-state-management-8738dd920e16
9. Unlocking AI Memory: A Deep Dive into the Mekanixms SQLite MCP Server, 12월 23, 2025에 액세스, https://skywork.ai/skypage/en/unlocking-ai-memory-sqlite-mcp-server/1978640090500734976
10. jlowin/fastmcp: The fast, Pythonic way to build MCP servers and clients - GitHub, 12월 23, 2025에 액세스, https://github.com/jlowin/fastmcp
11. Read This Before Building AI Agents: Lessons From The Trenches - DEV Community, 12월 23, 2025에 액세스, https://dev.to/isaachagoel/read-this-before-building-ai-agents-lessons-from-the-trenches-333i
12. How to Secure Your FastMCP Server With Permission Management - Cerbos, 12월 23, 2025에 액세스, https://www.cerbos.dev/blog/how-to-secure-your-fast-mcp-server-with-permission-management
13. MCP Filesystem Server by safurrier - Glama, 12월 23, 2025에 액세스, https://glama.ai/mcp/servers/@safurrier/mcp-filesystem
14. Model Context Protocol (MCP) Server Filesystem: A Comprehensive Guide for AI Engineers, 12월 23, 2025에 액세스, https://skywork.ai/skypage/en/Model-Context-Protocol-(MCP)-Server-Filesystem-A-Comprehensive-Guide-for-AI-Engineers/1971094888359784448
15. Building MCP Servers with an AI Agent - YouTube, 12월 23, 2025에 액세스, https://www.youtube.com/watch?v=QOqrqPx7_C0
16. hannesrudolph/sqlite-explorer-fastmcp-mcp-server - GitHub, 12월 23, 2025에 액세스, https://github.com/hannesrudolph/sqlite-explorer-fastmcp-mcp-server
17. How to build an MCP Server, 12월 23, 2025에 액세스, https://vivekpandit.medium.com/how-to-build-an-mcp-server-8fe627994c73
18. What is the best way to open a file for exclusive access in Python? - Stack Overflow, 12월 23, 2025에 액세스, https://stackoverflow.com/questions/186202/what-is-the-best-way-to-open-a-file-for-exclusive-access-in-python
19. Simplest way to get a process file lock in a cross platform way : r/learnpython - Reddit, 12월 23, 2025에 액세스, https://www.reddit.com/r/learnpython/comments/1dmsmgf/simplest_way_to_get_a_process_file_lock_in_a/
20. Learn MCP by building an SQL AI Agent : r/LangChain - Reddit, 12월 23, 2025에 액세스, https://www.reddit.com/r/LangChain/comments/1jdcuix/learn_mcp_by_building_an_sql_ai_agent/