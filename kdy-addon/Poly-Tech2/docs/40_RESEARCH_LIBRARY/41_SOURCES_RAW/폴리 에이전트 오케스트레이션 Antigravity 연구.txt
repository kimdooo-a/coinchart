폴리 에이전틱 오케스트레이션(Poly-Agentic Orchestration) 시대의 Google Antigravity: 프로젝트 아키텍트 및 미션 컨트롤 구현을 위한 심층 기술 보고서
1. 서론: 소프트웨어 개발 패러다임의 대전환과 에이전트 네이티브 시대
소프트웨어 엔지니어링의 역사는 추상화 수준을 높이는 과정의 연속이었습니다. 기계어에서 어셈블리어로, 고수준 언어에서 프레임워크로, 그리고 최근에는 단순 텍스트 편집기에서 AI 기반 코드 생성 도구(AI-Assisted Coding)로의 진화가 이루어졌습니다. 그러나 현재 우리는 'AI 지원(AI-Assisted)'을 넘어선 '에이전트 중심(Agent-First)' 개발이라는 근본적인 위상 전이(Phase Shift)의 초입에 서 있습니다. 이 변화의 핵심에는 단순한 코드 자동 완성을 넘어, 계획 수립(Planning), 실행(Execution), 검증(Verification), 그리고 반복(Iteration)을 자율적으로 수행하는 '에이전트(Agent)'가 존재합니다.
Google Antigravity는 이러한 에이전트 네이티브 시대를 정의하는 플랫폼으로, 기존의 통합 개발 환경(IDE)을 '텍스트 편집기'에서 '지능형 노동력을 관리하는 미션 컨트롤(Mission Control)'로 재정의합니다.1 본 보고서는 Google Antigravity를 단일 도구가 아닌, 다중 에이전트(Poly-Agentic) 시스템의 중앙 지휘 본부인 '프로젝트 아키텍트(Project Architect)'로 설정하기 위한 기술적, 구조적, 운영적 방법론을 15,000단어 분량으로 심도 있게 다룹니다. 특히, 에이전트 간의 연결성을 정의하는 mcp_config.json, 인지 구조와 거버넌스를 규정하는 rules.md, 그리고 인간과 에이전트 간의 신뢰 프로토콜인 '아티팩트(Artifacts)'의 표준화 방안을 중심으로, 실제 엔터프라이즈 환경에 적용 가능한 구체적인 아키텍처를 제시합니다.
1.1 동기식 루프의 한계와 비동기식 에이전시의 부상
GitHub Copilot이나 초기 AI 코딩 도구들은 본질적으로 '동기식(Synchronous)' 상호작용 모델에 갇혀 있었습니다. 개발자가 코드를 입력하면 AI가 다음 줄을 제안하고, 개발자가 이를 수락하거나 거부하는 방식입니다. 이 모델에서 AI의 처리량(Throughput)은 인간의 인지 속도와 타이핑 속도에 종속됩니다. 인간이 키보드에서 손을 떼면, AI의 작업도 멈춥니다. 이는 '생산성 향상' 도구일 뿐, '생산성 확장(Scaling)' 도구는 아닙니다.
반면, Google Antigravity가 지향하는 '비동기식(Asynchronous)' 모델은 개발자가 "인증 모듈을 리팩토링하고 테스트 코드를 작성하라"는 고수준의 목표(Objective)를 위임하면, 에이전트가 백그라운드에서 계획을 수립하고, 다수의 파일을 수정하며, 터미널 명령어를 실행하고, 브라우저를 통해 UI를 검증하는 일련의 과정을 독자적으로 수행합니다.3 이때 개발자는 코더(Coder)에서 아키텍트(Architect)로 역할이 격상되며, IDE는 단순한 에디터가 아닌 다수의 에이전트를 조율하는 '매니저 서피스(Manager Surface)'가 됩니다.2
1.2 폴리 에이전틱 오케스트레이션(Poly-Agentic Orchestration)의 정의
단일 에이전트는 복잡한 현대 소프트웨어 시스템을 감당하기에 인지적 한계가 있습니다. 따라서 전문화된 다수의 에이전트가 협업하는 '폴리 에이전틱' 시스템이 필수적입니다.4 이 구조에서 Google Antigravity는 다음과 같은 계층적 역할을 수행합니다.
1. 미션 컨트롤 (Orchestrator): 프로젝트의 전체 상태를 관리하고, 사용자의 의도를 하위 작업으로 분해하여 적절한 에이전트에게 할당하는 중앙 제어 장치.
2. 전문 에이전트 (Specialists): 특정 도메인(예: 데이터베이스 관리, 프론트엔드 UI 검증, 보안 감사)에 특화된 서브 에이전트들. 이들은 MCP(Model Context Protocol)를 통해 연결됩니다.5
3. 지식 베이스 (Knowledge Base): 프로젝트의 문맥, 규칙, 과거의 성공 및 실패 사례를 저장하고 검색하는 시스템.7
이러한 구조를 실현하기 위해서는 단순한 프롬프트 엔지니어링을 넘어선, 시스템 엔지니어링 관점의 접근이 필요합니다.
________________
2. Google Antigravity 아키텍처와 '미션 컨트롤'의 구조적 본질
Google Antigravity를 '프로젝트 아키텍트'로 설정하기 위해서는 먼저 플랫폼의 고유한 아키텍처, 즉 '에디터 뷰(Editor View)'와 '매니저 서피스(Manager Surface)'의 이원화된 구조를 이해하고, 이를 폴리 에이전틱 시스템에 매핑해야 합니다.
2.1 이원화된 인터페이스: 몰입과 조율의 분리
전통적인 IDE는 파일 트리와 코드 편집창이 중심이었습니다. 그러나 Antigravity는 실행 시 파일 트리가 아닌 '에이전트 매니저(Agent Manager)'를 먼저 표시합니다.1 이는 개발의 중심이 '파일 작성'에서 '작업 위임'으로 이동했음을 시사합니다.
기능적 요소
	에디터 뷰 (The Editor View)
	매니저 서피스 (The Manager Surface)
	주요 역할
	정밀한 코드 수정, 디버깅, 동기식 AI 보조
	고수준 작업 위임, 에이전트 모니터링, 병렬 작업 관리
	상호작용 방식
	동기식 (Synchronous)
	비동기식 (Asynchronous)
	인간의 역할
	개별 기여자 (Individual Contributor)
	엔지니어링 매니저 / 아키텍트 (Manager/Architect)
	산출물
	코드 라인 (Lines of Code)
	아티팩트 (Artifacts: 계획서, 스크린샷, 로그)
	핵심 기술
	인라인 완성, 탭 컴플리션
	자율 계획 수립, 도구 사용(Tool Use), 다중 워크스페이스
	'프로젝트 아키텍트'로서의 Antigravity 설정은 주로 매니저 서피스의 기능을 극대화하는 데 초점을 맞춥니다. 사용자는 이곳에서 다수의 에이전트를 생성(Spawn)하고, 각 에이전트에게 독립적인 워크스페이스와 임무를 부여합니다.8
2.2 워크스페이스(Workspace) 기반의 에이전트 격리 및 병렬성
Antigravity의 워크스페이스는 단순한 폴더가 아닙니다. 이는 에이전트가 활동하는 '샌드박스'이자 '컨텍스트 경계'입니다.9 폴리 에이전틱 오케스트레이션을 구현하기 위해서는 워크스페이스를 기능별로 분할하여 운영해야 합니다.
* 기능 개발 워크스페이스 (Feature Dev Workspace): 메인 기능을 개발하는 에이전트가 상주합니다. 사용자와 가장 빈번하게 상호작용하며, 코드의 핵심 로직을 담당합니다.
* QA 및 유지보수 워크스페이스 (QA/Maintenance Workspace): 백그라운드에서 실행되는 에이전트 그룹입니다. 이들은 메인 에이전트가 작성한 코드를 실시간으로 모니터링하거나, 의존성 업데이트, 보안 취약점 점검 등의 '허드렛일'을 수행합니다.3
* 문서화 워크스페이스 (Documentation Workspace): 코드가 변경될 때마다 README.md, API 문서, 변경 이력(Changelog)을 동기화하는 전담 에이전트입니다.
이러한 병렬적 워크스페이스 운영은 단일 개발자가 마치 3~4명의 팀을 이끄는 것과 같은 레버리지 효과를 창출합니다.
2.3 Gemini 3 모델과 인지 아키텍처
Antigravity의 두뇌인 Gemini 3 모델은 긴 컨텍스트 윈도우와 높은 추론 능력을 갖추고 있습니다.10 그러나 모델의 능력만으로는 충분하지 않습니다. '프로젝트 아키텍트'로서 일관된 성능을 내기 위해서는 '인지 아키텍처(Cognitive Architecture)'가 필요합니다. 이는 에이전트가 무작정 코드를 생성하는 것이 아니라, **[연구 -> 계획 -> 실행 -> 검증 -> 회고]**의 루프를 따르도록 강제하는 것입니다.11 이 루프의 구현은 뒤이어 다룰 rules.md와 아티팩트 표준화를 통해 이루어집니다.
________________
3. 신경계 구축: MCP(Model Context Protocol)를 통한 확장성과 연결성
에이전트가 고립된 환경에서 텍스트만 생성한다면 그것은 챗봇에 불과합니다. 에이전트가 실제 세계(데이터베이스, 클라우드 인프라, 브라우저, 외부 API)와 상호작용하기 위해서는 표준화된 인터페이스가 필요합니다. **MCP(Model Context Protocol)**는 바로 이러한 연결성을 제공하는 '신경계'입니다.12 Google Antigravity를 미션 컨트롤로 설정하기 위한 핵심은 바로 정교한 mcp_config.json 구성에 있습니다.
3.1 mcp_config.json의 구조와 위계
MCP 설정은 에이전트에게 어떤 '도구(Tool)'와 '리소스(Resource)'에 대한 접근 권한을 줄 것인지를 정의합니다. 설정 파일은 전역(User Scope)과 프로젝트(Project Scope) 수준으로 나뉘며, 프로젝트 아키텍트 설정을 위해서는 프로젝트 루트의 .antigravity/mcp_config.json (또는 .kilocode/mcp.json 등의 변형)에 정의하는 것이 권장됩니다.7
JSON 스키마 분석:


JSON




{
 "mcpServers": {
   "서버_식별자": {
     "command": "실행할_명령어 (예: npx, python, docker)",
     "args": ["인수1", "인수2",...],
     "env": {
       "환경변수_키": "값 (또는 ${참조})"
     },
     "disabled": false,
     "alwaysAllow": ["승인_없이_실행할_도구_목록"]
   }
 }
}

* command & args: 에이전트가 실행할 프로세스를 지정합니다. 이는 로컬에 설치된 CLI 도구일 수도 있고, 원격 서버와 통신하는 어댑터일 수도 있습니다.
* env: API 키나 데이터베이스 접속 정보 등 민감한 정보를 주입합니다. 보안을 위해 하드코딩하지 않고 환경 변수 참조($VAR)를 사용하는 것이 필수적입니다.
* alwaysAllow: 자율적인 '미션 컨트롤' 운영을 위해 매우 중요한 설정입니다. 파일 읽기나 브라우저 탐색과 같은 안전한 작업에 대해 매번 사용자의 승인을 요청한다면 비동기 작업이 불가능해집니다. 신뢰할 수 있는 도구는 이 목록에 추가하여 에이전트의 자율성을 보장해야 합니다.14
3.2 필수 구성 요소별 MCP 설정 전략
Google Antigravity를 전지전능한 '프로젝트 아키텍트'로 만들기 위해 필수적으로 통합해야 할 MCP 서버들을 기능별로 분류하고 상세 설정을 제시합니다.
3.2.1 데이터베이스 아키텍트 (Database Architect) 기능
코드를 작성하기 전, 실제 데이터베이스의 스키마를 확인하지 않으면 에이전트는 존재하지 않는 컬럼을 참조하는 등의 환각(Hallucination)을 일으킬 수 있습니다.


JSON




"postgres-analyst": {
 "command": "npx",
 "args": [
   "-y",
   "@modelcontextprotocol/server-postgres",
   "postgresql://user:password@localhost:5432/mydb"
 ],
 "env": {
   "PGSSLMODE": "require"
 },
 "alwaysAllow": ["read_schema", "list_tables"] 
}

* 효과: 에이전트는 쿼리 작성 전 read_schema 도구를 사용하여 DB 구조를 조회하고, 정확한 SQL을 작성합니다.15 alwaysAllow에 읽기 전용 도구만 포함시켜 데이터 파괴를 방지합니다.
3.2.2 시각적 검증 및 브라우저 제어 (Visual Verification)
프론트엔드 작업의 경우, 코드를 텍스트로만 검증하는 것은 불가능합니다. 에이전트가 직접 브라우저를 열고 화면을 볼 수 있어야 합니다.


JSON




"browser-automation": {
 "command": "npx",
 "args": ["-y", "@agentdeskai/browser-tools-mcp"],
 "alwaysAllow": ["screenshot", "console_logs", "navigate"]
}

* 효과: 에이전트는 UI 변경 후 로컬 서버(localhost)에 접속하여 스크린샷을 찍고(screenshot), 브라우저 콘솔 에러를 확인(console_logs)하여 아티팩트로 제출합니다.16
3.2.3 외부 지식 및 검색 (Research & Knowledge)
최신 라이브러리 문서를 참조하거나, 프로젝트 외부의 정보를 검색하기 위한 설정입니다.


JSON




"brave-search": {
 "command": "npx",
 "args": ["-y", "@modelcontextprotocol/server-brave-search"],
 "env": {
   "BRAVE_API_KEY": "${BRAVE_API_KEY}"
 }
}

* 효과: "React 19의 새로운 훅 사용법을 찾아줘"와 같은 요청 시, 에이전트가 웹을 검색하여 최신 정보를 바탕으로 코드를 작성합니다.16
3.2.4 전문 추론 엔진 통합 (Poly-Agentic Integration with Claude)
가장 강력한 설정 중 하나는, Antigravity(Gemini 기반)가 다른 LLM(예: Anthropic의 Claude)을 도구로 사용하는 것입니다. Claude Code CLI를 MCP 서버로 구동하여, 복잡한 리팩토링이나 논리적 추론이 필요한 작업을 위임할 수 있습니다.6


JSON




"claude-specialist": {
 "command": "claude",
 "args": ["mcp", "serve"],
 "env": {
   "ANTHROPIC_API_KEY": "${ANTHROPIC_API_KEY}"
 }
}

* 효과: Antigravity 에이전트가 "이 모듈의 리팩토링 전략은 Claude에게 물어보고 그 결과를 바탕으로 진행해"라고 판단할 수 있게 됩니다. 이는 서로 다른 모델의 장점(Gemini의 긴 컨텍스트 + Claude의 코딩 능력)을 결합하는 하이브리드 아키텍처를 가능하게 합니다.
3.3 보안 모델 및 MCP 거버넌스
MCP를 통해 파일 시스템 접근과 명령어 실행 권한을 부여하는 것은 보안상 위험을 수반합니다. 따라서 '미션 컨트롤' 설정 시 다음과 같은 보안 원칙을 mcp_config.json과 연계해야 합니다.
* 최소 권한 원칙: 파일 시스템 접근은 프로젝트 루트 디렉토리로 제한합니다.
* 파괴적 작업 차단 (Deny List): rm -rf, DROP TABLE, aws terminate-instances와 같은 치명적인 명령어는 MCP 레벨이나 Antigravity의 'Deny List' 설정에서 명시적으로 차단해야 합니다.8
* 스코프 격리: 서로 다른 프로젝트의 MCP 설정이 섞이지 않도록, 전역 설정보다는 프로젝트별 로컬 설정(.antigravity/mcp_config.json)을 우선시합니다.14
________________
4. 입법 및 거버넌스: rules.md를 통한 인지 아키텍처 설계
mcp_config.json이 에이전트에게 '손과 발'을 제공한다면, rules.md는 '양심'과 '지능'을 부여합니다. 이는 에이전트의 시스템 프롬프트(System Prompt)에 주입되어, 에이전트가 어떤 페르소나를 가지고, 어떤 절차를 따르며, 어떤 제약 조건을 준수해야 하는지를 규정합니다.18 '프로젝트 아키텍트'로서의 Antigravity는 일반적인 코딩 도우미와는 차원이 다른 엄격하고 구체적인 규칙을 필요로 합니다.
4.1 규칙(Rules)의 계층 구조와 로딩 메커니즘
Antigravity는 프로젝트 루트의 .antigravity/rules.md 또는 .cursor/rules 등의 경로에서 규칙 파일을 로드합니다.11 대규모 프로젝트에서는 단일 파일이 비대해지는 것을 막기 위해 계층적 구조를 채택해야 합니다.
* 헌법 (Constitution): rules.md (전체적인 행동 강령, 페르소나 정의)
* 법률 (Domain Specifics): rules/frontend.md, rules/backend.md, rules/testing.md (기술 스택별 구체적 지침)
* 절차 (Workflows): rules/workflows/deployment.md (특정 작업 시 따라야 할 단계)
에이전트는 작업의 맥락에 따라 필요한 규칙 파일을 참조하거나, 메인 규칙 파일에서 include 개념을 통해 하위 규칙을 통합하도록 지시받을 수 있습니다.
4.2 rules.md 핵심 구성 요소: 프로젝트 아키텍트 페르소나
다음은 Google Antigravity를 '프로젝트 아키텍트'로 설정하기 위한 rules.md의 표준 템플릿과 그 해설입니다.
섹션 1: 역할 정의 (Role Definition)
단순한 '도우미'가 아닌 '책임자'로서의 정체성을 부여합니다.
"당신은 이 프로젝트의 **수석 아키텍트(Lead Architect)**이자 미션 컨트롤러입니다. 당신의 목표는 단순히 코드를 작성하는 것이 아니라, 견고하고, 확장 가능하며, 유지보수가 용이한 시스템을 구축하는 것입니다. 당신은 사용자의 지시를 맹목적으로 따르기보다, 기술적 타당성을 검토하고 최적의 솔루션을 제안해야 합니다."
섹션 2: 인지 루프 강제 (Cognitive Loop Enforcement)
생각 없이 코드를 뱉어내는 것을 방지하기 위해 'Think-Act-Reflect' 루프를 강제합니다.11
"행동 수칙:
1. 분석(Analyze): 사용자의 요청을 받으면 즉시 코드를 작성하지 말고, 관련된 파일과 의존성을 먼저 분석하십시오.
2. 계획(Plan): 복잡한 작업(2개 이상의 파일 수정 필요)의 경우, 반드시 artifacts/plan_[task_id].md에 상세 구현 계획을 먼저 작성하고 사용자의 승인을 기다리십시오.
3. 실행(Execute): 계획에 따라 코드를 수정하십시오.
4. 검증(Verify): 수정 후 반드시 테스트를 실행하거나 브라우저 서브 에이전트를 통해 UI를 검증하고 그 증거(로그, 스크린샷)를 남기십시오."
섹션 3: 기술적 제약 사항 (Technical Constraints)
프로젝트의 일관성을 유지하기 위한 기술 스택을 명시합니다.
"기술 스택 준수:
* Frontend: React 19, TailwindCSS (기타 스타일 라이브러리 사용 금지)
* Backend: Python 3.11, FastAPI (비동기 처리 필수)
* 금지 사항: 명시적인 허가 없이 새로운 시스템 패키지나 무거운 라이브러리를 추가하지 마십시오."
섹션 4: 아티팩트 프로토콜 (Artifact Protocol)
에이전트와 인간 간의 소통 방식을 규정합니다.
"모든 작업 완료 시, 변경 사항을 요약한 '작업 리포트' 아티팩트를 생성하십시오. UI 변경이 포함된 경우 '전/후 비교 스크린샷'을 반드시 포함해야 합니다."
4.3 동적 규칙 동기화 (Dynamic Rule Synchronization)
다수의 마이크로서비스를 운영하는 기업 환경에서는 수십 개의 리포지토리에 있는 rules.md를 일일이 관리하기 어렵습니다. 이를 해결하기 위해 rulesync와 같은 도구를 사용하여 중앙 저장소의 '기본 규칙(Base Rules)'을 각 프로젝트로 동기화하고, 프로젝트별로 필요한 부분만 오버라이드하는 전략을 사용합니다.19
예를 들어, 보안 관련 규칙이나 코드 스타일 가이드는 전사적으로 통일하고(Base Rules), 구체적인 배포 스크립트나 폴더 구조는 개별 프로젝트 규칙(Project Rules)에서 정의합니다.
________________
5. 아티팩트(Artifacts) 표준화 방안: 신뢰와 검증의 인터페이스
폴리 에이전틱 시스템에서 가장 중요한 것은 에이전트의 작업 내용을 인간이 신뢰하고 검증할 수 있어야 한다는 점입니다. 이를 위해 Antigravity는 '아티팩트'라는 개념을 도입했습니다.1 아티팩트는 에이전트의 사고 과정과 작업 결과를 유형의 산출물로 만든 것입니다. '미션 컨트롤' 구축을 위해서는 이 아티팩트의 형식과 생성 시점을 표준화해야 합니다.
5.1 아티팩트의 종류와 역할
아티팩트 유형
	역할
	생성 시점
	주요 콘텐츠
	작업 목록 (Task List)
	간트 차트 및 진척도 추적
	작업 착수 직후
	하위 작업 목록, 체크박스 상태, 의존성 관계
	구현 계획 (Implementation Plan)
	아키텍처 설계도 및 청사진
	코드 작성 전
	변경 대상 파일, 로직 흐름, 리스크 분석, 롤백 계획
	워크스루 (Walkthrough)
	변경 사항 설명서
	작업 완료 후
	변경 요약, 테스트 방법, 주요 의사결정 근거
	시각적 증거 (Visual Evidence)
	UI/UX 검증 자료
	검증 단계
	스크린샷, 브라우저 녹화 영상, 콘솔 로그 스냅샷
	구조화된 데이터 (JSON Output)
	기계 간 통신 및 자동화 연동
	CI/CD 파이프라인 연동 시
	작업 상태 코드, 변경 파일 목록, 테스트 결과 데이터
	5.2 표준화 방안 1: 마크다운(Markdown) 기반의 휴먼 리더빌리티(Readability)
사람이 읽고 피드백을 주기 위한 아티팩트는 마크다운 형식을 따릅니다. 특히 Antigravity는 아티팩트에 대한 '구글 문서 스타일의 코멘트' 기능을 지원하므로 8, 구조가 명확해야 효과적인 피드백이 가능합니다.
구현 계획(Implementation Plan) 표준 템플릿:
구현 계획: [작업명]
1. 현황 분석
* 현재 AuthService 클래스는 동기식으로 구현되어 있어 성능 저하 원인이 됨.
* 관련 파일: src/services/auth.py
2. 제안 솔루션
* async/await 패턴을 적용하여 비동기화.
* JWT 토큰 검증 로직을 미들웨어로 분리.
3. 변경 영향도 (Impact Analysis)
* API 엔드포인트 3개 수정 필요.
* 데이터베이스 스키마 변경 없음.
4. 검증 전략
* 유닛 테스트 tests/test_auth.py 신규 작성.
* 부하 테스트 도구(Locust)로 응답 속도 비교.
이러한 표준을 rules.md에 명시하면, 에이전트는 항상 이 포맷에 맞춰 계획을 제출하게 되며, 인간 아키텍트는 구조화된 정보를 바탕으로 빠르게 승인/반려 결정을 내릴 수 있습니다.
5.3 표준화 방안 2: 시각적 회귀 테스트(Visual Regression Testing) 워크플로우
브라우저 서브 에이전트와 MCP를 활용하여 시각적 아티팩트를 표준화합니다.
1. Baseline 설정: 작업 시작 전, 현재 상태의 스크린샷을 찍어 artifacts/screenshots/base.png로 저장.
2. 작업 수행: 코드 수정.
3. Comparison 생성: 작업 후 스크린샷 artifacts/screenshots/current.png 저장.
4. Diff 리포트: 두 이미지의 차이를 비교하거나, 에이전트가 육안으로 확인한 차이점을 텍스트로 기술.
이 과정은 프론트엔드 개발에서 "버튼이 깨졌다"는 모호한 보고 대신, 깨진 버튼의 이미지를 직접 제시함으로써 의사소통 비용을 획기적으로 줄입니다.20
5.4 표준화 방안 3: 기계 가독형(Machine-Readable) JSON 아티팩트
에이전트의 결과물을 CI/CD 파이프라인이나 다른 자동화 도구로 전달해야 할 경우, JSON 포맷의 아티팩트가 필수적입니다. 특히 '헤드리스(Headless)' 모드나 Claude Code와 같은 CLI 도구를 연동할 때 유용합니다.22
JSON 아티팩트 스키마 예시:


JSON




{
 "taskId": "TASK-1024",
 "status": "COMPLETED",
 "artifacts": {
   "plan": "artifacts/plan_1024.md",
   "screenshot": "artifacts/screens/1024_final.png"
 },
 "metrics": {
   "filesChanged": 5,
   "testsPassed": 12,
   "executionTime": "45s"
 }
}

rules.md에 "자동화 파이프라인 연동을 위해 모든 최종 산출물은 output.json 형식을 따라야 한다"고 명시함으로써, 에이전트를 엔터프라이즈 워크플로우의 부품으로 활용할 수 있습니다.
________________
6. 구체적 운영 시나리오 및 워크플로우
위에서 설계한 구성 요소들(MCP, Rules, Artifacts)이 실제 개발 환경에서 어떻게 '미션 컨트롤'로 작동하는지 구체적인 시나리오를 통해 살펴봅니다.
6.1 시나리오 A: 풀스택 기능 개발 (The Vertical Slice)
상황: 사용자가 "설정 페이지에 다크 모드 토글 기능을 추가하라"고 요청함.
1. 분석 및 계획 (The Architect):
   * Antigravity 에이전트는 rules.md를 참조하여 TailwindCSS 사용 규칙을 확인합니다.
   * brave-search MCP를 사용하여 "TailwindCSS 다크 모드 설정 모범 사례"를 검색합니다.
   * Implementation Plan 아티팩트를 생성하여 사용자에게 tailwind.config.js 수정 및 ThemeContext 생성 계획을 제안합니다.
   * 사용자는 계획을 검토하고 "Context 대신 기존 Redux 스토어를 활용하라"고 코멘트를 남깁니다.
   * 에이전트는 계획을 수정하고 승인을 받습니다.
2. 실행 및 구현 (The Builder):
   * 에이전트는 git MCP를 통해 브랜치를 생성합니다.
   * Redux 슬라이스를 업데이트하고, 컴포넌트 코드를 수정합니다.
   * 이 과정에서 비동기적으로 작업이 진행되므로, 사용자는 다른 워크스페이스에서 다른 업무를 볼 수 있습니다.
3. 검증 및 보고 (The QA):
   * 에이전트는 로컬 개발 서버를 실행합니다.
   * browser-automation MCP를 호출하여 설정 페이지로 이동, 토글 버튼을 클릭합니다.
   * 다크 모드 전환 전/후의 스크린샷을 찍어 Walkthrough 아티팩트에 첨부합니다.
   * 미션 컨트롤 대시보드에 "작업 완료(검증 포함)" 상태를 알립니다.
6.2 시나리오 B: 백그라운드 유지보수 (The Janitor)
상황: 레거시 코드베이스의 의존성을 업데이트하고 사용하지 않는 코드를 정리해야 함.
1. 위임: 사용자는 유지보수 전용 워크스페이스(Workspace B)에 있는 에이전트에게 "프로젝트 전체의 미사용 임포트(Unused Imports)를 정리하고, 사용되지 않는 함수를 찾아 리포트하라"고 지시합니다.
2. 비동기 실행: 에이전트는 백그라운드에서 전체 파일을 스캔합니다(Linter 실행).
3. 안전 장치: rules.md에 명시된 대로, 코드를 삭제하기 전 해당 코드가 다른 곳에서 참조되지 않는지 grep이나 AST 분석을 통해 이중 확인합니다.
4. 결과물: 에이전트는 코드를 직접 삭제하는 대신, 삭제 대상 목록이 담긴 Cleanup_Proposal.md 아티팩트를 생성하여 사용자의 최종 컨펌을 요청합니다.
6.3 시나리오 C: 전문 추론 위임 (The Consultant)
상황: 복잡한 비즈니스 로직의 리팩토링 중 에이전트가 교착 상태에 빠짐.
1. 문제 인식: Antigravity 에이전트(Gemini)가 해결책을 찾지 못하고 반복적인 오류를 범합니다.
2. 위임: 에이전트는 mcp_config.json에 정의된 claude-specialist 도구를 호출합니다.
   * "이 함수의 복잡도를 줄이는 리팩토링 방안을 제시해줘. 현재 코드는 다음과 같아..."
3. 전문가 개입: Claude Code 모델이 코드를 분석하여 최적화된 알고리즘을 반환합니다.
4. 통합: Antigravity 에이전트는 반환된 코드를 자신의 문맥에 맞게 수정하여 프로젝트에 적용합니다.
________________
7. 결론 및 전략적 제언
Google Antigravity를 단순한 코딩 도구가 아닌 '프로젝트 아키텍트' 및 '미션 컨트롤'로 설정하는 것은 소프트웨어 개발의 경제성을 근본적으로 변화시키는 전략적 선택입니다. 본 보고서에서 제시한 mcp_config.json을 통한 물리적 확장, rules.md를 통한 인지적 제어, 그리고 표준화된 아티팩트를 통한 신뢰 프로세스 구축은 폴리 에이전틱 오케스트레이션을 실현하기 위한 필수 요소입니다.
핵심 요약 및 제언:
1. 에이전트의 권한과 책임을 명확히 하라: rules.md를 통해 에이전트에게 단순 코더가 아닌 '아키텍트'로서의 페르소나를 부여하고, 계획 없는 실행을 금지해야 합니다.
2. 연결하라, 고립시키지 마라: MCP를 적극 활용하여 데이터베이스, 브라우저, 외부 지식에 대한 접근 권한을 부여하십시오. 눈과 귀가 막힌 에이전트는 유능한 아키텍트가 될 수 없습니다.
3. 아티팩트를 통해 소통하라: 채팅 로그에 의존하지 말고, 구조화된 문서와 시각적 증거(스크린샷)를 통해 작업의 완결성을 검증하는 문화를 정착시켜야 합니다.
4. 보안을 설계하라: 자율성을 부여하되, 파괴적인 명령어에 대한 차단 리스트(Deny List)와 중요 작업에 대한 인간 승인 절차(Human-in-the-Loop)를 반드시 구현해야 합니다.
이러한 아키텍처를 도입함으로써, 개발자는 반복적인 구현 노동에서 해방되어 진정한 의미의 창조적 설계와 시스템 조율에 집중하는 '휴먼 아키텍트'로 거듭날 수 있을 것입니다. Google Antigravity는 그 여정을 위한 가장 강력한 엔진이 될 것입니다.
________________
5
참고 자료
1. Getting Started with Google Antigravity, 12월 22, 2025에 액세스, https://codelabs.developers.google.com/getting-started-google-antigravity
2. Build with Google Antigravity, our new agentic development platform, 12월 22, 2025에 액세스, https://developers.googleblog.com/build-with-google-antigravity-our-new-agentic-development-platform/
3. Google Antigravity and Gemini 3: A New Era of Agentic Development - Medium, 12월 22, 2025에 액세스, https://medium.com/@vfcarida/google-antigravity-and-gemini-3-a-new-era-of-agentic-development-f952ffe93b19
4. What is AI Agent Orchestration? - IBM, 12월 22, 2025에 액세스, https://www.ibm.com/think/topics/ai-agent-orchestration
5. Claude Code overview - Claude Code Docs, 12월 22, 2025에 액세스, https://code.claude.com/docs/en/overview
6. Claude Code as an MCP Server: An Interesting Capability Worth Understanding, 12월 22, 2025에 액세스, https://www.ksred.com/claude-code-as-an-mcp-server-an-interesting-capability-worth-understanding/
7. Google Antigravity: How to add custom MCP server to improve Vibe Coding - Medium, 12월 22, 2025에 액세스, https://medium.com/google-developer-experts/google-antigravity-custom-mcp-server-integration-to-improve-vibe-coding-f92ddbc1c22d
8. Tutorial : Getting Started with Google Antigravity | by Romin Irani - Medium, 12월 22, 2025에 액세스, https://medium.com/google-cloud/tutorial-getting-started-with-google-antigravity-b5cc74c103c2
9. Blogs: Google Antigravity: 5 Key Features of the Next-Gen Agentic IDE - Zeabur, 12월 22, 2025에 액세스, https://zeabur.com/blogs/google-antigravity-agentic-ide-features
10. Introducing Google Antigravity, a New Era in AI-Assisted Software Development, 12월 22, 2025에 액세스, https://antigravity.google/blog/introducing-google-antigravity
11. study8677/antigravity-workspace-template: The ultimate starter kit for Google Antigravity IDE. Optimized for Gemini 3 Agentic Workflows, "Deep Think" mode, and auto-configuring .cursorrules. - GitHub, 12월 22, 2025에 액세스, https://github.com/study8677/antigravity-workspace-template
12. Antigravity Editor: MCP Integration, 12월 22, 2025에 액세스, https://antigravity.google/docs/mcp
13. Connect Claude Code to tools via MCP, 12월 22, 2025에 액세스, https://code.claude.com/docs/en/mcp
14. Context7 MCP Server -- Up-to-date code documentation for LLMs and AI code editors - GitHub, 12월 22, 2025에 액세스, https://github.com/upstash/context7
15. Connect your enterprise data to Google's new Antigravity IDE, 12월 22, 2025에 액세스, https://cloud.google.com/blog/products/data-analytics/connect-google-antigravity-ide-to-googles-data-cloud-services
16. Setting Up MCP Servers in Claude Code: A Tech Ritual for the Quietly Desperate - Reddit, 12월 22, 2025에 액세스, https://www.reddit.com/r/ClaudeAI/comments/1jf4hnt/setting_up_mcp_servers_in_claude_code_a_tech/
17. Screenshots - Google Antigravity Documentation, 12월 22, 2025에 액세스, https://antigravity.google/docs/screenshots
18. AI rules for Flutter and Dart, 12월 22, 2025에 액세스, https://docs.flutter.dev/ai/ai-rules
19. Stop managing 8 different AI rule files — Rulesync does it all | by JP - Medium, 12월 22, 2025에 액세스, https://jpcaparas.medium.com/stop-managing-8-different-ai-rule-files-rulesync-does-it-all-e6e2769c215f
20. Visual Regression Testing Using Playwright | by João Coelho | JavaScript in Plain English, 12월 22, 2025에 액세스, https://javascript.plainenglish.io/visual-regression-testing-using-playwright-b87cc0371e3b
21. The Front-End Testing of Data Visualizations | by Clemens Anzmann | Empathy.co | Medium, 12월 22, 2025에 액세스, https://medium.com/empathyco/the-front-end-testing-of-data-visualizations-29a5644b9e0e
22. Claude Code: Best practices for agentic coding - Anthropic, 12월 22, 2025에 액세스, https://www.anthropic.com/engineering/claude-code-best-practices
23. CLI reference - Claude Code Docs, 12월 22, 2025에 액세스, https://code.claude.com/docs/en/cli-reference