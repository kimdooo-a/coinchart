폴리 에이전트 오케스트레이션(Poly-Agentic Orchestration): 4대 AI 개발 플랫폼의 단일 프로젝트 통합 및 분업화 아키텍처 연구 보고서
1. 서론: AI 개발 환경의 파편화와 통합의 필요성
소프트웨어 엔지니어링의 패러다임은 단순한 도구 보조(Tool-Assisted) 시대를 넘어 에이전트 중심(Agent-Centric) 생태계로 급격히 전환되고 있습니다. 개발자는 더 이상 코드를 직접 타이핑하는 '작성자'에 머무르지 않고, AI 에이전트들의 작업을 지시하고 검토하는 '설계자'이자 '감독관'의 역할을 수행하게 됩니다. 그러나 현재의 AI 개발 도구 시장은 각기 다른 강점과 독점적인 에이전트 아키텍처를 가진 도구들로 파편화되어 있습니다. Claude Code는 터미널 기반의 강력한 리팩토링 및 DevOps 능력을 1, Google Antigravity는 비동기식 에이전트 관리와 거시적 계획 수립 능력을 3, Cursor는 실시간 코드 작성 및 인간과의 상호작용(Flow) 최적화를 4, 그리고 **Visual Studio Code(VS Code)**는 방대한 확장 생태계와 안정적인 디버깅 환경을 제공합니다.6
본 연구 보고서는 이 네 가지 도구를 경쟁 관계가 아닌 상호 보완적인 기능적 장기(Organ)로 해석하고, 이를 단일 프로젝트 루트(Single Project Root) 내에서 공존시키며 유기적으로 분업화하는 '쿼드-하이브리드 개발 환경(Quad-Hybrid Development Environment, QHDE)' 아키텍처를 제안합니다. 또한, 이들 간의 작업 흐름을 제어하고 컨텍스트 충돌을 방지하며 업무를 배분하는 **'메타 오케스트레이터 에이전트(Meta-Orchestrator Agent)'**의 기술적 구현 방안을 LangGraph와 MCP(Model Context Protocol)를 기반으로 상세히 기술합니다.
________________
2. 통합 아키텍처의 철학: 단일 소스 저장소로서의 파일 시스템
서로 다른 인지 아키텍처를 가진 네 개의 AI 도구가 하나의 프로젝트에서 충돌 없이 작동하기 위해서는, 파일 시스템을 단순한 저장 공간이 아닌 '공유 메모리 버스(Shared Memory Bus)'이자 '데이터베이스'로 취급해야 합니다. 각 도구는 고유의 설정 파일과 메모리 구조를 가지며, 이를 물리적으로 격리하면서도 논리적으로 연결하는 디렉터리 구조 설계가 QHDE의 핵심입니다.
2.1 디렉터리 구조 및 구성 격리 전략
네 가지 도구가 동일한 루트 폴더를 공유할 때 가장 우려되는 점은 설정 충돌(Configuration Conflict)입니다. 예를 들어, Cursor의 린팅 규칙이 VS Code의 설정과 충돌하거나, Antigravity의 에이전트 로그가 Claude Code의 컨텍스트 윈도우를 오염시킬 수 있습니다. 이를 방지하기 위해 본 연구는 다음과 같은 엄격한 '구성 격리(Configuration Isolation)' 및 '상태 공유(State Sharing)' 디렉터리 구조를 제안합니다.


디렉터리/파일
	소유 에이전트 (Owner)
	기능 및 역할
	접근 권한 정책
	.antigravity/
	Google Antigravity
	미션(Mission) 데이터, 장기 계획(Plan), 아티팩트(Artifacts), 비동기 작업 로그 저장소.8
	Antigravity(쓰기), 타 에이전트(읽기)
	.cursor/
	Cursor
	로컬 임베딩 인덱스, Composer 히스토리, .cursorrules 저장소.10
	Cursor(쓰기), 타 에이전트(읽기 불가)
	.vscode/
	VS Code
	launch.json(디버깅), tasks.json, 워크스페이스 설정.
	VS Code(쓰기), 타 에이전트(읽기)
	.claude/
	Claude Code
	CLI 세션 기록, 비용 추적 로그, 인증 토큰 저장소.12
	Claude(쓰기)
	CLAUDE.md
	Claude Code (공유)
	프로젝트 헌법. 코딩 표준, 빌드 명령, 아키텍처 패턴을 정의하는 핵심 컨텍스트 파일.2
	인간/Antigravity(쓰기), 전원(읽기)
	.cursorrules
	Cursor (공유)
	Cursor 에이전트를 위한 행동 지침. CLAUDE.md와 동기화되어야 함.13
	인간/오케스트레이터(쓰기), Cursor(읽기)
	mcp_config.json
	오케스트레이터
	모든 에이전트를 연결하는 MCP 서버 레지스트리 설정 파일.14
	오케스트레이터(관리), 전원(참조)
	이 구조의 핵심은 '에이전트 메모리'와 '프로젝트 컨텍스트'의 분리입니다. .antigravity나 .cursor 폴더는 각 도구의 내부 상태를 저장하므로 .gitignore에 포함하여 버전 관리에서 제외해야 합니다. 반면, CLAUDE.md나 .cursorrules는 프로젝트의 '헌법' 역할을 하므로 모든 에이전트가 참조할 수 있도록 관리되어야 하며, 오케스트레이터 에이전트는 이 두 파일의 내용이 논리적으로 일치하도록 동기화를 유지해야 합니다.
2.2 지연 시간 계층화(Latency Stratification) 이론
이 아키텍처는 각 도구를 단순히 기능(Function)으로 나누는 것을 넘어, **시간적 작동 범위(Temporal Operational Scope)**에 따라 분류합니다. 이는 시스템의 효율성을 극대화하는 핵심 이론입니다.
* 즉시성(Real-time, <1s): Cursor와 VS Code는 인간의 사고 속도에 맞춰 즉각적인 피드백과 편집을 제공하는 영역입니다.
* 배치성(Batch, min): Claude Code는 수 분 단위의 시간이 소요되는 대규모 리팩토링, 테스트 실행, 린트 수정을 백그라운드 터미널에서 수행합니다.
* 장기성(Long-term, hours): Antigravity는 전체 프로젝트의 구조를 분석하고, 문서를 탐색하며, 다단계 계획을 수립하고 검증하는 긴 호흡의 작업을 담당합니다.
이러한 계층화는 개발자가 "기다리는 시간"을 제거합니다. 리팩토링이 필요할 때 개발자는 작업을 멈추고 기다리는 대신, Claude Code에게 작업을 위임하고 즉시 다른 창조적인 작업(Cursor)으로 전환할 수 있습니다.
________________
3. 컴포넌트 별 상세 역할 및 인지 프로파일링
효율적인 분업화를 위해서는 각 도구의 '인지적 강점(Cognitive Strength)'을 정확히 파악하고 역할을 부여해야 합니다.
3.1 Google Antigravity: 프로젝트 아키텍트 및 미션 컨트롤 (The Architect)
핵심 역할: 거시적 계획 수립, 비동기 에이전트 관리, 요구사항 검증
인지 프로파일: Gemini 3 Pro (Deep Think) 모델을 기반으로 방대한 컨텍스트를 이해하고 추론하는 데 특화되어 있습니다.16 Antigravity는 코드를 한 줄씩 작성하는 '타이피스트'가 아니라, 작업을 설계하고 하위 에이전트에게 지시하는 '매니저'입니다.
세부 분업화 전략:
1. 미션(Mission) 정의 및 분할: 사용자가 "결제 시스템을 통합해줘"라고 요청하면, Antigravity는 이를 "DB 스키마 설계", "API 엔드포인트 작성", "프론트엔드 연동" 등의 하위 태스크로 분할하여 .antigravity/plans/ 디렉터리에 마크다운 형식의 계획서로 저장합니다.17
2. 비동기 리서치: 코딩 도중 외부 라이브러리의 최신 문서 확인이 필요할 때, Antigravity의 브라우징 에이전트를 호출하여 문서를 학습하고 요약하게 합니다. 이는 인간 개발자가 IDE를 떠나지 않게 합니다.3
3. 최종 검증(QA): 개발이 완료된 후, Antigravity는 브라우저를 제어하여 실제 애플리케이션을 실행하고, UI가 기획 의도와 일치하는지 스크린샷을 찍어 검증하는 '시각적 회귀 테스트'를 수행합니다.8
3.2 Claude Code: 헤드리스 DevOps 엔지니어 (The Operator)
핵심 역할: 대규모 리팩토링, Git 운영, 터미널 자동화, 린팅/포맷팅
인지 프로파일: 터미널 환경(CLI)에 상주하며, 파일 시스템 조작과 쉘 명령어 실행에 최적화된 'Unix 철학'을 따릅니다.1 '헤드리스 모드(Headless Mode)'를 통해 UI 없이 백그라운드에서 명령을 수행할 수 있는 유일한 에이전트입니다.2
세부 분업화 전략:
1. 헤드리스 리팩토링: 오케스트레이터로부터 JSON 형식의 지시를 받으면, Claude Code는 사용자 개입 없이 수백 개의 파일을 스캔하고 수정합니다. 예를 들어, "모든 클래스 컴포넌트를 함수형으로 변환하라"는 지시를 백그라운드에서 수행합니다.18
2. Git 파수꾼: 커밋 메시지 작성, 브랜치 관리, 그리고 단순한 병합 충돌 해결을 담당합니다. git status를 지속적으로 모니터링하며 작업 내역을 정리합니다.1
3. 지능형 린터(Linter): 빌드 에러나 린트 에러가 발생하면, Claude Code는 이를 감지하고 스스로 코드를 수정하여 빌드가 성공할 때까지 반복(Loop) 작업을 수행합니다.
3.3 Cursor: 인터랙티브 리드 개발자 (The Interface)
핵심 역할: 비즈니스 로직 구현, 창의적 코딩, 인간-AI 협업(Vibe Coding)
인지 프로파일: 낮은 지연 시간과 높은 컨텍스트 인식률을 가지며, 인간의 의도를 실시간으로 코드로 변환하는 'Flow' 상태 유지에 최적화되어 있습니다.5
세부 분업화 전략:
1. 핵심 로직 구현: Antigravity가 설계하고 Claude가 스캐폴딩(기초 공사)을 마친 파일 위에서, 구체적이고 창의적인 비즈니스 로직을 작성합니다.
2. 실시간 코드 리뷰: Claude Code가 백그라운드에서 수정한 코드를 Cursor의 Diff 뷰를 통해 확인하고 승인합니다.
3. Vibe Coding: "이 버튼을 좀 더 튀게 만들어줘"와 같은 추상적인 디자인 요구사항을 즉시 반영하여 시각적인 결과물을 만들어냅니다.5
3.4 Visual Studio Code: 스페셜리스트 워크벤치 (The Specialist)
핵심 역할: 심층 디버깅, 레거시 호환성, 복잡한 충돌 해결
인지 프로파일: 가장 안정적이고 확장성이 뛰어난 기반 환경입니다. AI 기능보다는 도구적 신뢰성에 초점을 맞춥니다.
세부 분업화 전략:
1. 3-Way 병합: AI가 해결하지 못하는 복잡한 로직 충돌이 발생했을 때, VS Code의 강력한 '3-way merge editor'를 사용하여 인간이 정밀하게 개입합니다.6
2. 특수 언어 디버깅: C++, Rust, Java 등 복잡한 런타임 연결이 필요한 경우, VS Code의 성숙한 디버거를 활용합니다. 이를 위해 'AI 기능이 배제된 가벼운 프로필'을 별도로 설정하여 사용합니다.20
________________
4. 메타 오케스트레이터 에이전트(Meta-Orchestrator Agent) 설계 및 구현
단순히 네 가지 도구를 설치하는 것만으로는 진정한 통합이 이루어지지 않습니다. 이들을 조율할 '지휘자'가 필요합니다. 본 연구는 LangGraph와 **MCP(Model Context Protocol)**를 결합하여 로컬에서 실행되는 '메타 오케스트레이터' 구축을 제안합니다.
4.1 오케스트레이터 아키텍처 기술 사양
오케스트레이터는 프로젝트 루트에서 실행되는 경량 Python(또는 Node.js) 서버입니다. 이 에이전트는 파일 시스템 이벤트를 감시하고, 각 도구의 MCP 서버와 통신하며 작업을 라우팅합니다.
구성 요소:
1. 이벤트 감시기(Watcher): .antigravity/plans/, src/, .claude/ 폴더의 변경 사항을 실시간으로 감지합니다.
2. 라우터(Router): LangGraph 기반의 결정 엔진으로, 발생한 작업의 성격(계획, 실행, 수정, 디버깅)을 분석하여 적절한 에이전트에게 할당합니다.21
3. MCP 브리지(Bridge): 각 도구가 서로의 기능을 호출할 수 있도록 표준화된 인터페이스를 제공합니다.14
4.2 MCP 통합 설정 (mcp_config.json)
모든 도구가 참조할 단일 진실 공급원(Single Source of Truth)으로서 mcp_config.json을 프로젝트 루트에 생성합니다. 이를 통해 Antigravity나 Claude가 오케스트레이터의 도구(Tool)를 호출할 수 있게 됩니다.


JSON




{
 "mcpServers": {
   "orchestrator": {
     "command": "python",
     "args": ["./orchestrator/server.py"],
     "env": {
       "ANTHROPIC_API_KEY": "${env:ANTHROPIC_API_KEY}",
       "GEMINI_API_KEY": "${env:GEMINI_API_KEY}"
     }
   },
   "filesystem": {
     "command": "npx",
     "args": ["-y", "@modelcontextprotocol/server-filesystem", "./src"]
   },
   "claude-bridge": {
       "command": "claude",
       "args": ["-p", "--mcp-config", "./mcp_config.json"] 
   }
 }
}

14
4.3 LangGraph 기반 라우팅 로직 구현
오케스트레이터의 핵심 지능은 LangGraph의 상태 머신(State Machine)으로 구현됩니다. 다음은 작업의 유형에 따라 에이전트를 선택하는 라우터의 Python 의사 코드(Pseudocode)입니다.


Python




from langgraph.graph import StateGraph, END
from typing import TypedDict, Literal

class ProjectState(TypedDict):
   task_description: str
   file_context: list[str]
   complexity: str  # 'high', 'medium', 'low'
   assigned_agent: str

def classify_task(state: ProjectState):
   # LLM을 사용하여 태스크 분류
   # 예: "리팩토링" -> Claude, "기획/검증" -> Antigravity, "구현" -> Cursor
   if "refactor" in state['task_description'] or "lint" in state['task_description']:
       return "claude_agent"
   elif "plan" in state['task_description'] or "verify" in state['task_description']:
       return "antigravity_agent"
   else:
       return "cursor_human_handoff"

def trigger_claude(state: ProjectState):
   # Claude CLI를 헤드리스 모드로 호출
   import subprocess
   cmd = ["claude", "-p", state['task_description'], "--output-format", "json"]
   result = subprocess.run(cmd, capture_output=True, text=True)
   # 결과를 로그에 기록하고 종료
   return {"status": "completed", "output": result.stdout}

# 그래프 정의
workflow = StateGraph(ProjectState)
workflow.add_node("classifier", classify_task)
workflow.add_node("claude_agent", trigger_claude)
workflow.add_node("antigravity_agent", notify_antigravity) # Antigravity용 파일 생성
workflow.add_node("cursor_human_handoff", update_cursor_rules) #.cursorrules 업데이트

workflow.set_entry_point("classifier")
#... 조건부 엣지 설정...
app = workflow.compile()

21
이 로직은 사용자의 자연어 요청이나 파일 변경 이벤트를 입력으로 받아, 가장 적합한 도구를 자동으로 호출합니다.
________________
5. 에이전트 간 통신 프로토콜 (Inter-Agent Communication Protocol, IACP)
각 도구는 독립된 프로세스로 실행되므로, 직접적인 메모리 공유가 불가능합니다. 따라서 파일 시스템을 이용한 비동기 통신 프로토콜을 정의해야 합니다.
5.1 파일 기반 핸드오프 (Handoff) 메커니즘
1. Antigravity -> Claude (지시):
Antigravity가 계획을 수립하면 .antigravity/plans/active_plan.md 파일을 생성합니다. 오케스트레이터는 이 파일의 생성을 감지하고, 해당 계획을 파싱하여 Claude Code에게 전달할 CLI 명령어를 생성합니다.
   * 명령어 예시: claude -p "Read.antigravity/plans/active_plan.md and execute step 1 to 3" --output-format json.2
   2. Claude -> Cursor (알림):
Claude가 작업을 완료하면 결과 리포트를 .claude/outbox/report_task_123.json에 저장합니다. 오케스트레이터는 이를 감지하고, Cursor가 참조하는 TODO.md 파일이나 .cursorrules 파일에 "Claude가 리팩토링을 완료했습니다. 검토가 필요합니다."라는 주석을 추가합니다. 이는 Cursor 사용자에게 시각적인 알림(Diff 확인 요청)으로 작용합니다.
5.2 파일 잠금(Locking) 및 충돌 방지
동시에 여러 에이전트가 같은 파일을 수정하는 것을 막기 위해 '세마포어(Semaphore)' 시스템을 도입합니다.
      * 작동 원리: Claude Code나 Antigravity가 특정 디렉터리(예: src/auth/)에서 작업할 때, 오케스트레이터는 해당 폴더에 .agent_lock 파일을 생성합니다.
      * Cursor 규칙: .cursorrules에 ".agent_lock 파일이 존재하는 디렉터리는 편집하지 말 것"이라는 규칙을 명시하여, 인간 개발자가 충돌하는 작업을 수행하지 않도록 경고합니다.13
________________
6. 운영 시나리오: 통합 워크플로우 내러티브
본 아키텍처가 실제 개발 수명 주기에서 어떻게 작동하는지 세 가지 구체적인 시나리오를 통해 설명합니다.
6.1 시나리오 A: 신규 기능의 엔드 투 엔드(End-to-End) 개발
목표: 새로운 JWT 인증 모듈 개발
      1. 기획 (Antigravity): 개발자는 Antigravity에게 "JWT 인증 시스템을 설계해줘"라고 요청합니다. Antigravity는 'Deep Think' 모델을 가동하여 보안 요구사항을 분석하고, 필요한 라이브러리를 조사한 뒤, .antigravity/plans/AUTH_PLAN.md에 상세 구현 계획을 작성합니다.
      2. 스캐폴딩 (오케스트레이터 -> Claude): 오케스트레이터는 계획서를 감지하고, '초기 파일 생성 및 패키지 설치' 작업을 Claude Code에게 위임합니다. Claude는 백그라운드에서 mkdir src/auth, npm install jsonwebtoken 등을 수행하고 뼈대 코드를 작성한 뒤 커밋합니다.
      3. 구현 (Cursor): 개발자는 Cursor를 열고 구체적인 로직을 작성합니다. 이때 Cursor는 CLAUDE.md에 정의된 코딩 스타일을 참조하여 일관성 있는 코드를 제안합니다. 개발자는 Claude가 만들어둔 뼈대 위에 비즈니스 로직을 채워 넣습니다(Vibe Coding).
      4. 검증 (Antigravity): 구현이 완료되면 개발자는 Antigravity에게 검증을 요청합니다. Antigravity는 로컬 서버를 띄우고 브라우저를 제어하여 실제 로그인을 시도, 성공 여부를 스크린샷으로 남겨 보고합니다.8
6.2 시나리오 B: 레거시 코드의 현대화 및 대규모 리팩토링
목표: 프로젝트 전체의 데이터베이스 접속 패턴 변경
      1. 분석 (VS Code/Antigravity): 개발자는 VS Code의 디버거를 통해 DB 연결 누수를 발견합니다. 이 정보를 Antigravity에게 전달하여 원인을 분석하게 합니다. Antigravity는 "싱글톤 패턴으로의 변경"을 제안합니다.
      2. 일괄 수정 (Claude Code): 이 작업은 수십 개의 파일을 수정해야 하므로 인간이 하기 번거롭습니다. 개발자는 오케스트레이터를 통해 Claude에게 "모든 DB 연결 코드를 싱글톤 패턴으로 리팩토링하라"고 지시합니다. Claude는 헤드리스 모드로 전체 파일을 순회하며 코드를 수정합니다.2
      3. 충돌 해결 (VS Code): Claude의 수정 사항이 현재 개발자가 작업 중인 파일과 충돌을 일으켰습니다. AI 도구들은 복잡한 충돌 해결에 취약하므로, 개발자는 VS Code의 '3-way merge editor'를 열어 정밀하게 충돌을 해결하고 병합을 완료합니다.6
________________
7. 결론 및 향후 전망
본 보고서가 제안하는 **쿼드-하이브리드 개발 환경(QHDE)**은 현재의 AI 도구들이 가진 한계를 극복하는 가장 현실적이고 강력한 대안입니다. 어떤 단일 도구도 완벽하지 않습니다. Antigravity는 비전(Vision)을 가졌으나 미세 편집의 '손맛'이 부족하고, Claude Code는 강력한 힘(Power)을 가졌으나 직관적인 인터페이스가 없으며, Cursor는 몰입(Flow)을 제공하지만 거시적 관리가 약합니다. VS Code는 이 모든 것의 안전망입니다.
이 네 가지 도구를 단일 프로젝트 폴더에 통합하고 MCP 기반의 오케스트레이터로 연결함으로써, 우리는 개발자를 단순한 코더에서 'AI 군단의 지휘관'으로 격상시킬 수 있습니다. 파일 시스템을 데이터베이스로 활용하고, 작업의 시간적 특성에 따라 도구를 배분하는 이 아키텍처는 향후 소프트웨어 개발의 표준 운영 절차(SOP)가 될 잠재력을 가지고 있습니다.
실행 제언
      1. 단계적 도입: 먼저 Claude Code와 Cursor의 병행 사용부터 시작하여, Claude를 '백그라운드 처리기'로 활용하는 습관을 들이십시오.
      2. 오케스트레이터 구축: 본 보고서의 4장과 9장(부록)에 기술된 mcp_config.json과 Python 라우터를 구현하여 자동화 수준을 높이십시오.
      3. 규칙의 명문화: CLAUDE.md와 .cursorrules를 작성하여 에이전트들이 따를 공통의 법률을 제정하십시오.
이 통합 아키텍처를 통해 개발팀은 단순 반복 작업에서 해방되어, 더 높은 수준의 아키텍처 설계와 문제 해결에 집중할 수 있게 될 것입니다.
________________
9. 부록: 기술 구현 참조 자료
9.1 CLAUDE.md 템플릿 (프로젝트 헌법)
Claude Code Project Constitution
Role & Responsibility
당신은 이 프로젝트의 수석 DevOps 엔지니어입니다. 터미널 명령 실행과 Git 관리, 대규모 리팩토링을 전담합니다.
Interaction Protocol
      1. 작업 시작 전 반드시 .antigravity/plans/ 폴더의 최신 계획을 읽으십시오.
      2. .agent_lock 파일이 존재하는 디렉터리는 절대 수정하지 마십시오.
      3. 모든 실행 결과는 JSON 형식으로 오케스트레이터에게 반환해야 합니다.
Build & Test
      * Build Command: npm run build
      * Test Command: npm test
      * Lint Command: npm run lint -- --fix

2
9.2 .cursorrules 템플릿 (인간 협업 규칙)
Cursor Agent Rules
Context Awareness
당신은 'Antigravity(기획)'와 'Claude(실행)'와 협업하는 인터페이스 에이전트입니다.
         * 사용자의 지시가 "계획"이나 "검증"에 가깝다면 Antigravity에게 위임할 것을 제안하십시오.
         * 사용자의 지시가 "전체 파일 수정"이나 "설정 변경"이라면 Claude에게 위임할 것을 제안하십시오.
File Watching
         * TODO.md 파일이 변경되면 즉시 사용자에게 알림을 띄우십시오.
         * .agent_lock이 걸린 파일은 읽기 전용으로 취급하십시오.

13
참고 자료
            1. Claude Code overview - Claude Code Docs, 12월 22, 2025에 액세스, https://code.claude.com/docs/en/overview
            2. Claude Code: Best practices for agentic coding - Anthropic, 12월 22, 2025에 액세스, https://www.anthropic.com/engineering/claude-code-best-practices
            3. Getting Started with Google Antigravity, 12월 22, 2025에 액세스, https://codelabs.developers.google.com/getting-started-google-antigravity
            4. VS Code vs Cursor IDE: Choosing the Right Editor for AI-Enhanced Development - Medium, 12월 22, 2025에 액세스, https://medium.com/@techwhizai15/vs-code-vs-cursor-ide-choosing-the-right-editor-for-ai-enhanced-development-c5acdd487d91
            5. Why use Cursor instead of VS Code? What am I missing (Honest Question) - Reddit, 12월 22, 2025에 액세스, https://www.reddit.com/r/vibecoding/comments/1olnzuk/why_use_cursor_instead_of_vs_code_what_am_i/
            6. Resolve merge conflicts in VS Code, 12월 22, 2025에 액세스, https://code.visualstudio.com/docs/sourcecontrol/merge-conflicts
            7. Basic editing - Visual Studio Code, 12월 22, 2025에 액세스, https://code.visualstudio.com/docs/editing/codebasics
            8. How to Set Up and Use Google Antigravity - Codecademy, 12월 22, 2025에 액세스, https://www.codecademy.com/article/how-to-set-up-and-use-google-antigravity
            9. Tutorial : Getting Started with Google Antigravity | by Romin Irani - Medium, 12월 22, 2025에 액세스, https://medium.com/google-cloud/tutorial-getting-started-with-google-antigravity-b5cc74c103c2
            10. Using Cursor and VS Code in parallel? - Discussions, 12월 22, 2025에 액세스, https://forum.cursor.com/t/using-cursor-and-vs-code-in-parallel/6042
            11. Identity and Access Management | Cursor Docs, 12월 22, 2025에 액세스, https://cursor.com/docs/enterprise/identity-and-access-management
            12. Claude Code CLI Cheatsheet: config, commands, prompts, + best practices - Shipyard.build, 12월 22, 2025에 액세스, https://shipyard.build/blog/claude-code-cheat-sheet/
            13. Rules | Cursor Docs, 12월 22, 2025에 액세스, https://cursor.com/docs/context/rules
            14. Antigravity Editor: MCP Integration, 12월 22, 2025에 액세스, https://antigravity.google/docs/mcp
            15. Tutorial : Getting Started with Google MCP Services | by Romin Irani - Medium, 12월 22, 2025에 액세스, https://medium.com/google-cloud/tutorial-getting-started-with-google-mcp-services-60b23b22a0e7
            16. What Is Google Antigravity? Google's Gemini 3 Coding IDE - DEV Community, 12월 22, 2025에 액세스, https://dev.to/chloedavis/what-is-google-antigravity-googles-gemini-3-coding-ide-3j6g
            17. Introducing Google Antigravity, a New Era in AI-Assisted Software Development, 12월 22, 2025에 액세스, https://antigravity.google/blog/introducing-google-antigravity
            18. Claude Dev vs Claude Code: Which is Better for VS Code Users? - DEV Community, 12월 22, 2025에 액세스, https://dev.to/mechcloud_academy/claude-dev-vs-claude-code-which-is-better-for-vs-code-users-6el
            19. Features · Cursor, 12월 22, 2025에 액세스, https://cursor.com/features
            20. VS Code Migration | Cursor Docs, 12월 22, 2025에 액세스, https://cursor.com/docs/configuration/migrations/vscode
            21. LangGraph overview - Docs by LangChain, 12월 22, 2025에 액세스, https://docs.langchain.com/oss/python/langgraph/overview
            22. Router - Docs by LangChain, 12월 22, 2025에 액세스, https://docs.langchain.com/oss/python/langchain/multi-agent/router
            23. Building a Basic MCP Server with Python - DEV Community, 12월 22, 2025에 액세스, https://dev.to/alexmercedcoder/building-a-basic-mcp-server-with-python-5ci7
            24. Build a multi-source knowledge base with routing - Docs by LangChain, 12월 22, 2025에 액세스, https://docs.langchain.com/oss/python/langchain/multi-agent/router-knowledge-base
            25. Workflows and agents - Docs by LangChain, 12월 22, 2025에 액세스, https://docs.langchain.com/oss/python/langgraph/workflows-agents
            26. CLI reference - Claude Code Docs, 12월 22, 2025에 액세스, https://code.claude.com/docs/en/cli-reference
            27. Review | Cursor Docs, 12월 22, 2025에 액세스, https://cursor.com/docs/agent/review