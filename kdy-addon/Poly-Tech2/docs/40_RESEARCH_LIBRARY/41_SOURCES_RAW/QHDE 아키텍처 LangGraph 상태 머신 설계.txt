폴리 에이전트 오케스트레이션: LangGraph 기반 메타 오케스트레이터 엔진의 상태 머신 설계 및 Human-in-the-loop 아키텍처 심층 연구
1. 서론: 에이전트 네이티브 시대의 도래와 메타 오케스트레이션의 필연성
소프트웨어 엔지니어링의 패러다임은 현재 결정적인 위상 전이(Phase Shift)를 겪고 있다. 과거의 도구 보조(Tool-Assisted) 개발 방식이 인간의 인지적 부하를 줄이는 데 초점을 맞췄다면, 현재 부상하고 있는 에이전트 중심(Agent-Centric) 생태계는 개발 프로세스의 주도권을 인공지능(AI)에게 이양하고 인간은 이를 감독하는 구조로의 근본적인 변화를 예고한다. 이러한 변화의 중심에는 단순한 코드 자동 완성을 넘어, 스스로 계획을 수립하고(Planning), 도구를 사용하여 실행하며(Execution), 결과를 검증(Verification)하는 자율 에이전트들이 존재한다. 그러나 현재의 AI 개발 도구 시장은 각기 다른 인지 아키텍처와 독점적인 워크플로우를 가진 파편화된 도구들—Claude Code, Google Antigravity, Cursor, Visual Studio Code(VS Code)—로 분열되어 있다.1
본 연구 보고서는 이러한 파편화된 도구들을 경쟁 관계가 아닌 상호 보완적인 기능적 장기(Organ)로 재해석하고, 이를 단일 프로젝트 루트 내에서 유기적으로 통합하는 '쿼드-하이브리드 개발 환경(Quad-Hybrid Development Environment, QHDE)' 아키텍처를 제안한다. 특히, 이 복잡한 다중 에이전트 시스템을 제어하기 위해 LangGraph를 기반으로 한 메타 오케스트레이터 엔진(Meta-Orchestrator Engine)의 설계 방법론을 심도 있게 분석한다. LangGraph의 유향 비순환 그래프(DAG) 및 순환 그래프 구조는 에이전트 간의 작업 흐름을 결정론적으로 제어하고, 상태(State)를 체계적으로 관리하며, 결정적인 순간에 인간의 개입(Human-in-the-loop, HITL)을 강제하는 안전망을 제공하는 데 있어 최적의 기제임이 입증되었다.2
본고에서는 파일 시스템을 공유 메모리 버스(Shared Memory Bus)로 활용하는 데이터 구조, 모델 컨텍스트 프로토콜(MCP)을 통한 에이전트 간 신경망 구축, 그리고 LangGraph의 체크포인팅(Checkpointing) 및 인터럽트(Interrupt) 기능을 활용한 고도화된 거버넌스 로직을 15,000단어 규모의 심층 분석을 통해 기술한다. 이는 단순한 기술 통합을 넘어, 소프트웨어 개발이라는 행위 자체를 '작성'에서 '설계 및 조율'로 격상시키는 미래 지향적 아키텍처의 청사진이다.
2. 이론적 배경 및 아키텍처 철학
2.1 단일 에이전트의 한계와 폴리 에이전트 시스템의 부상
초기의 AI 코딩 도구들은 단일 거대 언어 모델(LLM)이 모든 작업을 수행하는 모놀리식(Monolithic) 접근 방식을 취했다. 그러나 소프트웨어 개발의 복잡성은 단일 모델의 컨텍스트 윈도우와 추론 능력을 초과하는 경우가 빈번하다. 예를 들어, 즉각적인 코드 완성이 필요한 상황과 장기적인 아키텍처 리팩토링이 필요한 상황은 서로 다른 인지적 특성과 지연 시간(Latency)을 요구한다.1
폴리 에이전트 시스템(Poly-Agentic System)은 이러한 문제를 전문화된 에이전트들의 분업화를 통해 해결한다. 본 연구에서 정의하는 QHDE 아키텍처는 각 도구의 특성을 다음과 같이 분류한다:
* The Architect (Google Antigravity): Gemini 3 Pro 모델을 기반으로 거시적 계획 수립, 비동기 에이전트 관리, 시각적 검증을 담당한다. 사용자가 고수준의 목표를 위임하면 백그라운드에서 계획을 수립하고 실행한다.1
* The Operator (Claude Code): 터미널 환경(CLI)에 상주하며, 파일 시스템 조작, Git 운영, 대규모 리팩토링을 수행하는 헤드리스(Headless) DevOps 엔지니어 역할을 수행한다.1
* The Interface (Cursor): 낮은 지연 시간과 높은 컨텍스트 인식률을 바탕으로 인간의 의도를 실시간 코드로 변환하는 'Flow' 상태 유지에 최적화된 인터랙티브 리드 개발자이다.1
* The Specialist (VS Code): 방대한 확장 생태계와 안정적인 디버깅 환경을 제공하며, AI 기능보다는 도구적 신뢰성과 격리된 작업 환경(Specialist Workbench)을 제공한다.1
2.2 공유 메모리 버스로서의 파일 시스템
서로 다른 프로세스로 실행되는 이 네 가지 도구가 충돌 없이 협업하기 위해서는 강력한 동기화 메커니즘이 필요하다. 본 아키텍처는 운영체제의 파일 시스템을 단순한 저장 공간이 아닌, 에이전트 간의 상태를 공유하고 통신하는 '공유 메모리 버스'이자 '데이터베이스'로 정의한다.1
디렉터리/파일
	소유 에이전트
	기능 및 역할
	접근 권한 정책
	.antigravity/
	Antigravity
	미션 데이터, 장기 계획, 아티팩트 저장소
	Antigravity(쓰기), 타 에이전트(읽기)
	.cursor/
	Cursor
	로컬 임베딩 인덱스, Composer 히스토리
	Cursor(쓰기), 타 에이전트(읽기 불가)
	.claude/
	Claude Code
	CLI 세션 기록, 비용 추적 로그
	Claude(쓰기)
	CLAUDE.md
	Shared
	프로젝트 헌법 (코딩 표준, 빌드 명령)
	인간/Antigravity(쓰기), 전원(읽기)
	.cursorrules
	Shared
	Cursor 행동 지침 (CLAUDE.md와 동기화)
	인간/오케스트레이터(쓰기), Cursor(읽기)
	mcp_config.json
	Orchestrator
	MCP 서버 레지스트리 설정 파일
	오케스트레이터(관리), 전원(참조)
	이러한 구조는 '에이전트 메모리'와 '프로젝트 컨텍스트'를 물리적으로 분리함으로써 구성 충돌(Configuration Conflict)을 방지한다. 특히 .antigravity나 .cursor 폴더는 각 도구의 내부 상태를 저장하므로 버전 관리에서 제외되어야 하며, CLAUDE.md와 같은 파일은 모든 에이전트가 참조하는 단일 진실 공급원(Single Source of Truth)으로 관리된다.
3. LangGraph 기반 메타 오케스트레이터 설계
메타 오케스트레이터는 이질적인 에이전트들을 하나의 논리적 흐름으로 묶어내는 중앙 제어 장치이다. LangGraph는 이러한 오케스트레이터를 구축하기 위한 최적의 프레임워크로, 상태(State)의 지속성(Persistence), 순환(Cycle) 처리, 그리고 제어 가능한 흐름(Controllable Flow)을 제공한다.3
3.1 상태 스키마(State Schema) 정의
LangGraph의 핵심은 그래프를 통해 전달되는 공유 데이터 구조인 '상태'를 정의하는 것이다. 본 오케스트레이터는 TypedDict를 사용하여 프로젝트의 전역 상태를 엄격하게 타입화한다.4 이는 에이전트 간의 데이터 교환 규격을 명확히 하고, 런타임 오류를 방지하는 데 필수적이다.


Python




from typing import TypedDict, List, Optional, Literal, Annotated
from langgraph.graph.message import add_messages

class AgentArtifact(TypedDict):
   """에이전트가 생성한 산출물 정의"""
   type: Literal["plan", "code", "report", "screenshot", "log"]
   path: str
   content_summary: str
   created_at: str

class ProjectState(TypedDict):
   """프로젝트 전체 상태 스키마"""
   # 사용자의 고수준 목표 (예: "JWT 인증 구현")
   objective: str
   # 현재 워크플로우 단계
   status: Literal["planning", "executing", "reviewing", "completed", "failed", "interrupted"]
   # 활성 에이전트 식별자
   active_agent: Optional[Literal["antigravity", "claude", "cursor", "human"]]
   # 생성된 아티팩트 목록 (Reducer 로직 적용 가능)
   artifacts: List[AgentArtifact]
   # 에이전트 간 대화 및 로그 히스토리
   messages: Annotated[List[str], add_messages]
   # 비용 제어를 위한 실행 횟수 카운터
   recursion_count: int
   # 마지막 오류 정보
   last_error: Optional[str]

이 스키마는 그래프의 각 노드(에이전트)가 실행될 때마다 업데이트되며, 체크포인터(Checkpointer)를 통해 영속적으로 저장된다. 이를 통해 시스템이 중단되더라도 이전 상태에서 정확히 재개할 수 있다.5
3.2 노드(Node) 및 엣지(Edge) 설계
오케스트레이터는 작업을 분류하고 라우팅하는 결정 엔진을 중심으로 구성된다. LangGraph의 노드는 각 에이전트의 기능을 캡슐화하며, 엣지는 상태에 따른 전이 논리를 정의한다.
3.2.1 분류기(Classifier) 및 라우터 노드
작업의 성격을 분석하여 적절한 에이전트에게 할당하는 진입점이다. 여기서는 LLM을 사용하여 자연어 요청을 분석하고, Command 객체를 반환하여 동적으로 다음 노드를 결정한다.6


Python




def router_node(state: ProjectState):
   """
   상태와 목표를 분석하여 작업을 라우팅하는 결정 노드
   """
   task = state['objective']
   
   # 기획이나 구조적 설계가 필요한 경우 -> Antigravity
   if "plan" in task or "design" in task or state['status'] == "planning":
       return Command(goto="antigravity_planner")
   
   # 대규모 리팩토링, 테스트, 린팅 -> Claude Code
   elif "refactor" in task or "test" in task or "lint" in task:
       return Command(goto="claude_executor")
       
   # UI 구현이나 창의적 코딩 -> Cursor (인간 핸드오프)
   else:
       return Command(goto="cursor_handoff")

3.2.2 Claude Code 실행 노드 (Headless Automation)
Claude Code는 CLI 기반이므로, 파이썬의 subprocess를 통해 비동기적으로 실행된다. 이때 중요한 것은 --dangerously-skip-permissions 플래그와 샌드박스 환경의 결합이다.1


Python




async def claude_executor(state: ProjectState):
   """
   Claude Code를 헤드리스 모드로 실행하는 노드
   """
   # 샌드박스 내에서 자율 실행을 위한 플래그 조합
   cmd = [
       "claude", 
       "-p", state['objective'], 
       "--output-format", "json", 
       "--dangerously-skip-permissions",  # 자율성 핵심 
       "--max-turns", "10"               # 비용 제어 
   
   # 프로세스 실행 및 결과 캡처
   process = await asyncio.create_subprocess_exec(
       *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
   )
   stdout, stderr = await process.communicate()
   
   # 결과 파싱 및 상태 업데이트
   return {
       "status": "reviewing",
       "artifacts": [{"type": "report", "content_summary": stdout.decode()}]
   }

3.2.3 Antigravity 기획 노드 (Asynchronous Signaling)
Antigravity는 IDE 형태이므로 직접 실행하는 것이 아니라, 파일 시스템을 통해 신호를 보낸다. 노드는 .antigravity/missions/ 폴더에 미션 파일을 생성하고, Antigravity 에이전트가 이를 감지하여 작업을 시작하도록 유도한다.1
3.3 동적 라우팅 및 병렬 처리
LangGraph의 Command 객체와 Send API를 활용하면 정적인 파이프라인을 넘어선 동적 라우팅이 가능하다. 예를 들어, Antigravity가 수립한 계획이 여러 개의 하위 모듈 개발을 포함할 경우, Send API를 사용하여 여러 개의 Claude 인스턴스나 서브 그래프를 병렬로 실행(Map-Reduce 패턴)할 수 있다.7 이는 단일 에이전트의 처리 속도 한계를 극복하고 개발 속도를 획기적으로 향상시킨다.
4. Human-in-the-Loop (HITL) 및 거버넌스 아키텍처
자율 에이전트 시스템에서 가장 중요한 것은 에이전트의 행동이 인간의 의도와 일치하도록 보장하는 것이다. '에이전트 표류(Agent Drift)'나 환각(Hallucination)을 방지하기 위해, 본 아키텍처는 LangGraph의 인터럽트 기능과 체크포인팅을 활용한 정교한 HITL 로직을 구현한다.
4.1 인터럽트(Interrupt) 패턴 설계
LangGraph의 interrupt 함수는 그래프 실행을 일시 중지하고 외부 입력(인간의 승인)을 기다리는 기능을 제공한다.8 이는 파괴적인 작업(예: DB 삭제, 프로덕션 배포)이나 중요한 의사결정 시점에 필수적이다.
시나리오: 파괴적 인프라 변경 감지
1. 감지: claude_executor 노드가 terraform apply 명령을 포함한 계획을 생성한다.
2. 분석: 노드 내부의 로직이 계획서 내의 destroy 키워드를 감지한다.
3. 인터럽트 발생: interrupt({"type": "approval_required", "reason": "Destructive action detected"})를 호출한다.8
4. 상태 저장 및 중지: LangGraph는 현재 스택과 상태를 체크포인터에 저장하고 실행을 멈춘다.
5. 사용자 개입: 개발자는 매니저 서피스(Antigravity)나 Cursor의 알림을 통해 계획을 검토하고 승인/반려 의사를 전송한다.
6. 재개(Resume): Command(resume="approved")를 통해 그래프가 중단된 지점부터 실행을 재개한다.9
4.2 체크포인팅(Checkpointing)과 영속성
HITL 워크플로우가 며칠에 걸쳐 진행될 수 있으므로, 상태의 영속성은 필수적이다. 본 아키텍처는 SqliteSaver 또는 PostgresSaver를 사용하여 모든 상태 전이를 데이터베이스에 기록한다.10
* 스레드(Thread) 관리: 각 미션은 고유한 thread_id를 가진다. 이를 통해 여러 개의 기능 개발 미션이 서로 간섭 없이 병렬로 진행될 수 있으며, 개발자는 언제든지 특정 미션의 시점을 '시간 여행(Time Travel)' 하듯 되돌릴 수 있다.5
* 상태 복구: 에이전트가 오류로 중단되거나 시스템이 재부팅되더라도, 체크포인트에서 마지막 상태를 로드하여 작업을 이어서 수행할 수 있다. 이는 장기 실행 프로세스(Long-running Process)의 안정성을 보장한다.11
4.3 alwaysAllow와 자율성의 균형
모든 작업에 대해 인간의 승인을 요구하는 것은 비효율적이다. 따라서 mcp_config.json 파일 내에 alwaysAllow 리스트를 정의하여, 파일 읽기, 브라우저 탐색, 스키마 조회와 같은 안전한 읽기 전용 작업은 에이전트가 자율적으로 수행하도록 허용한다.1 반면, 쓰기 작업이나 외부 API 호출은 denyList 또는 인터럽트 로직을 통해 엄격히 통제한다.
5. 에이전트 간 통신 프로토콜 (Inter-Agent Communication Protocol, IACP)
서로 다른 프로세스 공간에 존재하는 에이전트들이 협업하기 위해서는 표준화된 통신 규약이 필요하다. IACP는 파일 시스템을 메시지 버스로 활용하며, JSON 및 마크다운 형식의 아티팩트를 통해 정보를 교환한다.
5.1 파일 기반 핸드오프(Handoff) 메커니즘
* 지시(Instruction) 전달: Antigravity가 계획을 수립하면 .antigravity/plans/active_plan.md 파일을 생성한다. 오케스트레이터의 파일 감시자(File Watcher)는 이 이벤트를 감지하고, 해당 계획을 파싱하여 Claude Code에게 전달할 CLI 명령어를 생성한다.1
* 결과(Notification) 전달: Claude가 작업을 완료하면 결과 리포트를 .claude/outbox/report.json에 저장한다. 오케스트레이터는 이를 감지하여 Cursor의 TODO.md나 .cursorrules 파일에 주석을 추가함으로써 인간 개발자에게 시각적인 알림(Diff 확인 요청)을 보낸다.1
5.2 세마포어(Semaphore) 및 충돌 방지
다수의 에이전트가 동시에 동일한 파일을 수정하는 경쟁 조건(Race Condition)을 방지하기 위해 파일 기반 뮤텍스(Mutex) 시스템을 도입한다.1
* 락(Lock) 획득: 에이전트가 쓰기 작업을 시작하기 전, 해당 디렉토리에 .agent_lock 파일이 존재하는지 확인한다.
* 대기 및 점유: 락이 없으면 자신의 ID와 타임스탬프가 포함된 락 파일을 생성하고 작업을 시작한다.
* 강제 해제: 오케스트레이터는 데몬 프로세스를 통해 오래된 락(Stale Lock, 예: 5분 이상 경과)을 주기적으로 청소하여 교착 상태(Deadlock)를 방지한다.
5.3 MCP를 통한 신경망 연결
mcp_config.json은 에이전트들이 서로의 도구(Tool)를 호출할 수 있게 하는 레지스트리 역할을 한다.
* Claude as a Tool: Claude Code를 claude mcp serve 모드로 실행하여, Antigravity가 Claude의 추론 능력을 API처럼 호출할 수 있게 한다.1
* Browser as a Tool: @agentdeskai/browser-tools-mcp를 통해 에이전트가 브라우저를 제어하고, 스크린샷을 찍어 시각적 검증을 수행하도록 한다.1
6. 구현 시나리오 및 기술적 세부사항
6.1 시나리오: 레거시 코드의 현대화 및 테스트 자동화
1. 착수 (Cursor/Human): 개발자가 Cursor 채팅창에 "전체 DB 접속 코드를 ORM 기반으로 리팩토링하고 테스트를 작성해줘"라고 입력한다. Cursor는 이를 objective로 설정하고 LangGraph에 전달한다.
2. 계획 (Antigravity): 라우터 노드가 이를 '기획' 단계로 판단하여 Antigravity에게 위임한다. Antigravity는 코드베이스를 분석하고 리팩토링 계획서(plan.md)를 아티팩트로 생성한다.
3. 승인 (HITL): LangGraph는 계획서 생성을 감지하고 interrupt를 건다. 개발자는 계획서를 검토하고 승인 버튼을 누른다.
4. 실행 (Claude): 승인 신호를 받은 그래프는 Claude Code 노드를 병렬로 실행한다. Claude는 헤드리스 모드로 수백 개의 파일을 수정하고, pytest를 실행하여 검증한다.
5. 검증 및 완료 (Orchestrator): 테스트가 실패하면 Claude는 수정 루프를 돌고, 성공하면 결과 리포트를 생성한다. 오케스트레이터는 이를 취합하여 Cursor에게 알린다.
6.2 오케스트레이터 서버 구현 코드 (예시)
다음은 LangGraph를 사용하여 위 로직을 구현한 Python 코드의 일부이다.


Python




from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver

#... State 정의...

# 조건부 엣지 로직
def route_step(state: ProjectState):
   if state['status'] == "failed":
       # 재시도 횟수 확인
       if state['recursion_count'] > 3:
           return "human_help" # 사람에게 도움 요청
       return "claude_fixer" # Claude가 다시 수정 시도
   elif state['status'] == "review_required":
       return "human_approval"
   return END

# 그래프 구성
workflow = StateGraph(ProjectState)
workflow.add_node("antigravity_planner", plan_mission)
workflow.add_node("claude_executor", execute_task)
workflow.add_node("human_approval", get_human_input) # Interrupt 지점

workflow.set_entry_point("antigravity_planner")
workflow.add_edge("antigravity_planner", "human_approval")
workflow.add_conditional_edges("human_approval", route_approval)
workflow.add_conditional_edges("claude_executor", route_step)

# 체크포인터 설정 (영속성)
memory = SqliteSaver.from_conn_string("checkpoints.sqlite")
app = workflow.compile(checkpointer=memory, interrupt_before=["human_approval"])

이 코드는 상태의 지속성을 위해 SQLite를 사용하고, human_approval 노드 실행 직전에 작업을 멈추도록(interrupt_before) 설정되어 있다.12
7. 결론 및 향후 전망
본 연구에서 제안한 LangGraph 기반 메타 오케스트레이터와 QHDE 아키텍처는 AI 개발 도구의 파편화 문제를 해결하고, 개발자를 단순 코더에서 'AI 군단의 지휘관'으로 격상시키는 구체적이고 실현 가능한 방법론이다.
파일 시스템을 데이터베이스로 활용하는 IACP 프로토콜, LangGraph의 상태 머신을 이용한 결정론적 제어, 그리고 체크포인팅과 인터럽트를 통한 강력한 HITL 거버넌스는 에이전트 시스템의 신뢰성과 확장성을 담보한다. 특히 Google Antigravity의 거시적 계획 능력, Claude Code의 강력한 실행력, Cursor의 직관적 인터페이스, VS Code의 안정성을 결합함으로써, 우리는 단일 도구로는 불가능했던 복잡하고 거대한 소프트웨어 엔지니어링 과제를 자율적으로 수행할 수 있는 시스템을 구축할 수 있다.
향후 Gemini 3나 Claude 3.5 Opus와 같은 초거대 모델들이 발전함에 따라, 이 오케스트레이션 레이어는 더욱 중요해질 것이다. 에이전트의 지능이 높아질수록 그들을 통제하고 조율하는 '시스템의 지능' 또한 진화해야 하기 때문이다. 본 아키텍처는 그 진화의 방향성을 제시하는 나침반이 될 것이다.
8. 참고 문헌 및 설정 부록
8.1 주요 구성 파일 레퍼런스
* Claude Code 설정: -p (프린트 모드), -r (세션 재개), --output-format json 플래그 활용.1
* Antigravity 설정: 워크스페이스 분리(Feature, QA, Docs), mcp_config.json 내 alwaysAllow 설정.1
* LangGraph 설정: TypedDict 상태 스키마, SqliteSaver 체크포인터, interrupt 함수 활용.4
8.2 핵심 참조 자료
* 1 AI 도구 통합 개발 환경 연구: 폴리 에이전트 오케스트레이션 아키텍처.
* 1 Claude Code 오케스트레이션 연구: 헤드리스 DevOps 엔지니어 구현.
* 1 폴리 에이전트 오케스트레이션 Antigravity 연구: 미션 컨트롤 구현.
* 3 LangGraph Graph API Overview.
* 8 LangGraph Interrupts & Human-in-the-loop.
참고 자료
1. AI 도구 통합 개발 환경 연구.txt
2. LangGraph overview - Docs by LangChain, 12월 23, 2025에 액세스, https://docs.langchain.com/oss/python/langgraph/overview
3. Graph API overview - Docs by LangChain, 12월 23, 2025에 액세스, https://docs.langchain.com/oss/python/langgraph/graph-api
4. LangGraph Best Practices - Swarnendu De, 12월 23, 2025에 액세스, https://www.swarnendu.de/blog/langgraph-best-practices/
5. Persistence - Docs by LangChain, 12월 23, 2025에 액세스, https://docs.langchain.com/oss/python/langgraph/persistence
6. A Beginner's Guide to Dynamic Routing in LangGraph with Command() - DEV Community, 12월 23, 2025에 액세스, https://dev.to/aiengineering/a-beginners-guide-to-dynamic-routing-in-langgraph-with-command-2c5l
7. Best practices for parallel nodes (fanouts) - LangGraph - LangChain Forum, 12월 23, 2025에 액세스, https://forum.langchain.com/t/best-practices-for-parallel-nodes-fanouts/1900
8. Interrupts - Docs by LangChain, 12월 23, 2025에 액세스, https://docs.langchain.com/oss/python/langgraph/interrupts
9. How to wait for user input using interrupt - GitHub Pages, 12월 23, 2025에 액세스, https://langchain-ai.github.io/langgraph/how-tos/human_in_the_loop/wait-user-input/
10. Checkpointing | LangChain Reference, 12월 23, 2025에 액세스, https://reference.langchain.com/python/langgraph/checkpoints/
11. Orchestrating Long-Running Processes with LangGraph Agents - Auxiliobits, 12월 23, 2025에 액세스, https://www.auxiliobits.com/blog/orchestrating-long-running-processes-using-langgraph-agents/
12. LangGraph Breakpoints or Interrupt: How to Add Human-in-the-Loop Control to Your AI Workflows | by Sangeethasaravanan | Medium, 12월 23, 2025에 액세스, https://sangeethasaravanan.medium.com/build-llm-workflows-with-langgraph-breakpoints-and-interrupts-for-human-in-the-loop-control-bb311ce681c3